<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard | FlipCards</title>
    <link rel="stylesheet" href="flashcard.css">
    <link rel="icon" type="image/png" sizes="32x32" href="Group-100.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4779578721359852"
     crossorigin="anonymous"
     data-anchor-ad-position="bottom"
     data-enable-auto-ads-for-ad-unit-types="anchor-ads"></script>
</head>
<body>
    <header class="shop-header">
    <div class="header-left">
        <a href="#" id="backToFoldersBtn" class="back-button">‚Üê Back to Folders</a>
        <a href="shop.html" id="upgradeBtn" class="upgrade-button" style="display: none;">Upgrade your Plan</a>
    </div>
    <h2 class="shop-title">FlipCards.</h2>
</header>

    <main class="flashcard-main-container">
        <div id="feedbackText" class="floating-text"></div>
        <div class="meta-info">
            <div class="meta-item">
                <span>Category:</span>
                <strong id="cardCategory">General</strong>
            </div>
            <div class="meta-border"></div>
            <div class="meta-item">
                <span>Creator:</span>
                <strong id="cardCreator">N/A</strong>
            </div>
        </div>

        <div class="set-details">
    <div class="title-row">
    <div class="title-and-label">
        <span class="title-label">Title:</span>
        <h1 class="page-title" id="setTitle"></h1>
    </div>
    <div class="reverse-mode-container">
    <button id="reverseInfoBtn" class="info-icon">?</button>
    <span>Reverse Mode</span>
    <label class="toggle-switch">
        <input type="checkbox" id="reverseToggle" checked="">
        <span class="slider"></span>
    </label>
</div>
</div>
    <div class="description-container">
    <div class="description-box" id="descriptionBox">Loading description...</div>
</div>

<button id="exitReviewBtn" class="neumorphic-button exit-review-btn hidden">
    Exit Review Session
</button>
</div>

    <div class="button-container google-auto-ads-ignore">
    <button class="neumorphic-button active" onclick="navigateToMode('flashcard.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>Flashcard</button>
    <button class="neumorphic-button" onclick="navigateToMode('test.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="m10.4 12.6-2.8 2.8"></path><path d="m10.4 15.4-2.8-2.8"></path><path d="M12 18h6"></path></svg>

Test</button>
    <button id="blitzButton" class="neumorphic-button" onclick="navigateToMode('blitz.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
</svg>
    Blitz
    <img src="new.png" alt="New Feature" class="new-icon">
</button>
    <button class="neumorphic-button" onclick="navigateToMode('learn.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.232 5.232a3 3 0 0 1 0 4.242L12 12.728l-3.232-3.232a3 3 0 0 1 0-4.242a3 3 0 0 1 4.242 0z"></path><path d="M12 12.728 8.768 9.496a3 3 0 0 1 0 4.242L12 17.228l3.232-3.232a3 3 0 0 1 0-4.242z"></path></svg>

Learn</button>
    <button class="neumorphic-button" onclick="navigateToMode('match.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 7h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2z"></path><path d="M10 7V5.5a1.5 1.5 0 0 1 3 0V7"></path><path d="M14 17v1.5a1.5 1.5 0 0 1-3 0V17"></path><path d="M7 10H5.5a1.5 1.5 0 0 0 0 3H7"></path><path d="M17 14h1.5a1.5 1.5 0 0 0 0-3H17"></path></svg>
Match</button>
    <button class="neumorphic-button" onclick="navigateToMode('defidrop.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"></path><path d="m19 12-7-7"></path></svg>DefiDrop</button>
</div>
<div class="shortcut-bar google-auto-ads-ignore">
    <i class="fa-solid fa-keyboard"></i>
    <span class="shortcut-normal">Shortcut: Press <kbd class="shortcut-key">Space</kbd> or click on the card to flip.</span>
    <span class="shortcut-performance hidden">Shortcuts: <kbd class="shortcut-key">‚Üê</kbd> <i class="fa-regular fa-face-frown"></i> | <kbd class="shortcut-key">‚Üí</kbd> <i class="fa-regular fa-face-smile"></i></span>
</div>
        <div class="flashcard-container">
            <div class="flashcard">
                <div class="front"></div>
                <div class="back"></div>
            </div>
        </div>

        
        
<div class="navigation-controls">
    <div class="performance-monitor-container">
    <span>Monitor performance</span>
    <label class="toggle-switch">
        <input type="checkbox" id="performanceToggle">
        <span class="slider"></span>
    </label>
    <span id="reviewCounter" class="review-counter">0</span>
</div>

    <div class="nav-btn" id="prevBtn">
        <i class="fa-solid fa-chevron-left"></i>
    </div>
<div class="nav-btn" id="nextBtn">
        <i class="fa-solid fa-chevron-right"></i>
    </div>
    <div id="card-counter" class="card-counter">1 / 10</div>
<div class="nav-btn" id="shuffleBtn" title="Shuffle Cards">
        <i class="fa-solid fa-shuffle"></i>
    </div>
<div class="nav-btn" id="setKeyWordBtn" title="Set Key Word">
        <i class="fa-solid fa-key"></i>
    </div>

</div>

        
    </main>
<div id="flipTimerModal" class="flip-timer-modal hidden">
  <div class="flip-timer-header">
    <span class="flip-timer-title">üïí FlipTimer</span>
    <span class="flip-timer-close" onclick="closeFlipTimer()">&times;</span>
  </div>
  <div class="flip-timer-body">
    <label for="studyMinutes">Study Minutes:</label>
    <input type="number" id="studyMinutes" min="1" max="180" placeholder="Enter minutes...">
    <h2 id="flipTimerLabel">Ready to Focus?</h2>
    <h1 id="flipTimerClock">00:00</h1>

    <div class="flip-timer-buttons">
      <button onclick="startFlipTimer()">Start</button>
      <button onclick="resetFlipTimer()">Reset</button>
      <button onclick="skipBreak()">Skip</button>
      <button onclick="pauseFlipTimer()" id="pauseButton">‚è∏Ô∏è Pause</button>
    </div>

    <p>Breaks Taken: <span id="breakCounter">0</span></p>
    <div style="text-align: center; margin-top: 10px;">
      <button id="collapseBtn" onclick="collapseFlipTimer()" class="neumorphic-button" style="padding: 4px 12px; font-size: 12px;">‚ñ≤ Collapse</button>
    </div>
  </div>
</div>

<!-- FlipTimer Minimized View -->
<div id="flipTimerMinimized" class="hidden" style="
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 10px 16px;
  border-radius: 16px;
  font-family: 'QilkaBold';
  font-size: 16px;
  z-index: 3000;
  gap: 10px;
  align-items: center;
  box-shadow: 6px 6px 12px rgba(0,0,0,0.3), -6px -6px 12px rgba(255,255,255,0.05);
  cursor: pointer;
  border: 1px solid white;
  backdrop-filter: blur(8px);
  display: flex;
">
<span id="minBreakCounter">0</span>
  <span id="flipTimerMinClock">00:00</span>
   <button onclick="expandFlipTimer()" class="neumorphic-button" style="font-size: 12px; padding: 4px 10px;">‚ñ≤ Expand</button>
</div>

<!-- Confirm Dialog -->
<div id="flipTimerConfirm" class="flip-timer-confirm hidden">
  <div class="flip-timer-confirm-box">
    <p>Want to continue?</p>
    <div>
      <button onclick="confirmFlipTimerContinue(true)">Yes</button>
      <button onclick="confirmFlipTimerContinue(false)">No</button>
    </div>
  </div>
</div>
<div id="reverseInfoModal" class="modal-overlay">
  <div class="modal-box info-modal-content">
    <i class="fa-solid fa-lightbulb modal-info-icon"></i>
    <h3>What is Reverse Mode?</h3>
    <p>Reverse Mode swaps the term and definition. You will be shown the definition first and must recall the term.</p>
    <button id="closeReverseInfoModal" class="neumorphic-button">Got it</button>
  </div>
</div>
<div id="keyWordModal" class="modal-overlay">
<div class="modal-box info-modal-content key-word-modal-content">
  <i class="fa-solid fa-key modal-info-icon"></i>
  <h3>Set Key Word</h3>
  <p>Select a phrase from the definition below to set it as your key word for this card.</p>

  <div id="keyWordDefinition" class="key-word-definition-box">
    Loading definition...
  </div>

  <p class="key-word-selected-label">Your Key Word:</p>
  <div id="selectedKeyWord" class="key-word-selected-box">
    Select text above...
  </div>

  <div class="modal-buttons">
    <button id="closeKeyWordModalBtn" class="neumorphic-button">Cancel</button>
    <button id="saveKeyWordBtn" class="neumorphic-button">Save Key Word</button>
  </div>
</div>
</div>
<!-- ‚ñ≤‚ñ≤‚ñ≤ END OF NEW MODAL ‚ñ≤‚ñ≤‚ñ≤ -->
<div id="toggleSidenavBtn" class="sidenav-toggle-btn">
    <i class="fa-solid fa-chevron-right"></i>
</div>
<div id="toggleKeyWordSidenavBtn" class="sidenav-toggle-btn right">
    <i class="fa-solid fa-key"></i>
</div>
<div id="reviewSidenav" class="sidenav">
    <h3>Cards for Review</h3>
    <div class="sidenav-buttons">
        <button id="reviewBtn" class="sidenav-btn review">
            <i class="fa-solid fa-star"></i> Review
        </button>
        <button id="resetReviewBtn" class="sidenav-btn reset">
            <i class="fa-solid fa-trash"></i> Reset
        </button>
    </div>
    <div id="reviewCardsList">
        <p>Loading review cards...</p>
    </div>
</div>
<div id="keyWordSidenav" class="sidenav right">
    <h3>Key Word Presets</h3>
    <p class="sidenav-description">
      Presets for this set, shared by other users.
    </p>
    <div id="keyWordPresetList">
        <p>Loading presets...</p>
    </div>
</div>
<div id="customConfirmModal" class="custom-alert-backdrop hidden">
  <div class="custom-alert-content error">
    <p id="confirmMessage"></p>
    <div class="modal-buttons">
      <button id="confirmBtn" class="neumorphic-button">Confirm</button>
      <button id="cancelBtn" class="neumorphic-button">Cancel</button>
    </div>
  </div>
</div>
<div id="customAlertModal" class="custom-alert-backdrop hidden">
  <div class="custom-alert-content">
    <p id="customAlertMessage"></p>
    <button id="customAlertOkBtn" class="neumorphic-button">OK</button>
</div>
<script src="flipTimer.js"></script>

<script type="module">
  /**
   * Fetches and plays Google's Text-to-Speech audio.
   * @param {string} textToSpeak - The text from your flashcard.
   */
  async function playGoogleAudio(textToSpeak) {
    
    // Stop any currently playing audio before starting a new one
    if (currentAudio) {
      currentAudio.pause();
      currentAudio = null;
    }
    
    // ‚ö†Ô∏è PASTE YOUR GOOGLE API KEY HERE
    const API_KEY = 'AIzaSyCynM5G8GUw3uM8pjdgQkWAsKow3ph9tCg'; 
    
    const apiUrl = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`;

    const requestBody = {
      input: {
        text: textToSpeak
      },
      voice: {
        languageCode: 'en-US',
        name: 'en-US-WaveNet-G' // A premium "WaveNet" voice
      },
      audioConfig: {
        audioEncoding: 'MP3'
      }
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        // If the API key is wrong or restricted, this will show an error
        console.error('API Error Response:', await response.json());
        throw new Error(`Error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      // The audio is returned as a base64 string. We need to decode it.
      currentAudio = new Audio(`data:audio/mp3;base64,${data.audioContent}`);
      currentAudio.play();

      // Add an event listener to clear the variable when audio finishes
      currentAudio.onended = () => {
        currentAudio = null;
      };

    } catch (error) {
      console.error('Failed to fetch Google audio:', error);
      showCustomAlert('Failed to generate audio. Check the console for errors (e.g., API key restrictions).');
      currentAudio = null; // Also clear on error
    }
  }
  // --- ADD THIS NEW HELPER FUNCTION ---
  function createSpeakerIcon(textToSpeak) {
    const icon = document.createElement('i');
    icon.className = 'fa-solid fa-volume-high speaker-icon';
    
    icon.addEventListener('click', (e) => {
        e.stopPropagation(); // Stops the card from flipping
        playGoogleAudio(textToSpeak);
    });
    return icon;
  }
  // Import the Firebase functions we need
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, arrayUnion, arrayRemove, onSnapshot, collection, query, where, getDocs, addDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
  import { db } from "./firebaseinit.js";

  const auth = getAuth();

  // --- Global variables within the module ---
  let reverseMode = true;
  let currentIndex = 0;
  let flashcards = [];
  let currentReviewingSet = null; // ‚ñº‚ñº‚ñº NEW: Variable to store the fresh data ‚ñº‚ñº‚ñº
  let originalSetData = null; // To store the original set before review
  let currentAudio = null;
  let originalDefinitionText = "";
  let selectedKeyWordStartIndex = -1;
  let activePresetId = null;

  const keyWordSidenavBtn = document.getElementById('toggleKeyWordSidenavBtn');
  const keyWordSidenav = document.getElementById('keyWordSidenav');
  const keyWordPresetList = document.getElementById('keyWordPresetList');
  
const exitReviewBtn = document.getElementById('exitReviewBtn');

  // --- Get references to HTML elements ---
  const front = document.querySelector(".flashcard .front");
  const back = document.querySelector(".flashcard .back");
  const card = document.querySelector(".flashcard");
  const counter = document.getElementById("card-counter");
  const setKeyWordBtn = document.getElementById('setKeyWordBtn');
const keyWordModal = document.getElementById('keyWordModal');
const closeKeyWordModalBtn = document.getElementById('closeKeyWordModalBtn');
const keyWordDefinition = document.getElementById('keyWordDefinition');
const selectedKeyWord = document.getElementById('selectedKeyWord');
const saveKeyWordBtn = document.getElementById('saveKeyWordBtn');
  const reverseToggle = document.getElementById("reverseToggle");
  const backToFoldersBtn = document.getElementById("backToFoldersBtn");
  const feedbackText = document.getElementById('feedbackText');
  const reviewCounter = document.getElementById('reviewCounter');
const shuffleBtn = document.getElementById('shuffleBtn');
const shortcutNormalText = document.querySelector('.shortcut-normal');
const shortcutPerformanceText = document.querySelector('.shortcut-performance');

  onAuthStateChanged(auth, async (user) => {
    if (user && !user.isAnonymous) {
      const upgradeBtn = document.getElementById('upgradeBtn');
      const userRolesRef = doc(db, "approved_emails", user.email);
      const userRolesSnap = await getDoc(userRolesRef);

      if (userRolesSnap.exists()) {
        const roles = userRolesSnap.data().role.toLowerCase();
        if (!roles.includes('plus') && !roles.includes('verified')) {
          upgradeBtn.style.display = 'inline-block';
        }
      }
    }

    const reviewingSetId = localStorage.getItem("reviewingSetId");
    const collectionName = localStorage.getItem("reviewingSetCollection");
// +++ Get references to elements needed in both states +++
    const front = document.querySelector(".flashcard .front");
    const back = document.querySelector(".flashcard .back");
    const card = document.querySelector(".flashcard");
    const counter = document.getElementById("card-counter");
    const setTitleElem = document.getElementById("setTitle");
    const descriptionBoxElem = document.getElementById("descriptionBox");
    const categoryElem = document.getElementById("cardCategory");
    const creatorElem = document.getElementById("cardCreator");
    const prevBtnElem = document.getElementById("prevBtn");
    const nextBtnElem = document.getElementById("nextBtn");
    const shuffleBtnElem = document.getElementById("shuffleBtn");
    const modeButtons = document.querySelectorAll(".button-container .neumorphic-button");
    const performanceToggle = document.getElementById('performanceToggle');
    const reverseToggle = document.getElementById('reverseToggle');
    const sidenavToggle = document.getElementById('toggleSidenavBtn');
    const shortcutNormalText = document.querySelector('.shortcut-normal');
    const shortcutPerformanceText = document.querySelector('.shortcut-performance');
    // +++ End of getting references +++
    if (!reviewingSetId || !collectionName) {
      // --- NEW: Placeholder State when no ID is found ---
      console.warn("No reviewingSetId or collectionName found in localStorage. Displaying placeholder state.");

      // Keep the page structure, just update content
      front.textContent = "Please select a set";
      back.textContent = "from the lobby to begin.";
      card.classList.remove("flipped"); // Ensure card starts unflipped

      // Set default/placeholder text for other info
      setTitleElem.textContent = "No Set Loaded";
      descriptionBoxElem.textContent = "Please return to the lobby and select a flashcard set to review or study.";
      categoryElem.textContent = "-";
      creatorElem.textContent = "-";
      counter.textContent = "0 / 0";

      // Disable navigation buttons visually and functionally
      [prevBtnElem, nextBtnElem, shuffleBtnElem, setKeyWordBtn].forEach(btn => {
        btn.style.opacity = "0.5";
        btn.style.pointerEvents = "none";
        btn.onclick = null; // Remove click listeners if any were added dynamically
      });

      // Disable mode buttons
      modeButtons.forEach(button => {
        button.onclick = (e) => {
           e.preventDefault(); // Stop navigation
           // Use your existing alert function if available
           if (typeof showCustomAlert === 'function') {
               showCustomAlert("Please select a flashcard set from the lobby first.");
           } else {
               alert("Please select a flashcard set from the lobby first.");
           }
        };
        button.style.opacity = "0.6";
        button.style.cursor = "not-allowed";
        button.classList.remove('active'); // Ensure no button looks active
      });

      // Disable toggles
      if (performanceToggle) performanceToggle.disabled = true;
      if (reverseToggle) reverseToggle.disabled = true;

      // Hide specific elements
      if (sidenavToggle) sidenavToggle.style.display = 'none';
      if (shortcutNormalText) shortcutNormalText.textContent = 'Select a set in the lobby to enable shortcuts.';
      if (shortcutPerformanceText) shortcutPerformanceText.classList.add('hidden');


      return; // Stop execution here, don't try to fetch data
    }

    try {
      const setRef = doc(db, collectionName, reviewingSetId);
      const docSnap = await getDoc(setRef);

      if (docSnap.exists()) {
    const reviewingSetData = docSnap.data();

    // ‚ñº‚ñº‚ñº NEW: Store the original set data when the page first loads ‚ñº‚ñº‚ñº
    originalSetData = {
        flashcards: reviewingSetData.flashcards || [],
        title: reviewingSetData.title || "Untitled Set",
        description: reviewingSetData.description || "No description provided.",
        category: reviewingSetData.category || "General",
        creatorEmail: reviewingSetData.creatorEmail || reviewingSetData.user
    };
    // ‚ñ≤‚ñ≤‚ñ≤ END OF ADDITION ‚ñ≤‚ñ≤‚ñ≤

    currentReviewingSet = reviewingSetData;
    flashcards = reviewingSetData.flashcards || [];
    flashcards.forEach((card, index) => {
        card.originalIndex = index;
    });
if (user && !user.isAnonymous) {
        const presetRef = collection(db, "KeyWordPresets");
        const reviewingSetId = localStorage.getItem("reviewingSetId");

        // Query for a preset matching this user AND this set
        const q = query(presetRef, where("userEmail", "==", user.email), where("setId", "==", reviewingSetId));
        
        try {
            const querySnap = await getDocs(q);
            if (!querySnap.empty) {
                const myPreset = querySnap.docs[0].data();
                activePresetId = querySnap.docs[0].id;
                if (myPreset.keyWords) {
                    const fetchedKeyWords = myPreset.keyWords;
                    console.log("DEBUG 1: Fetched *own* Key Word Preset:", JSON.stringify(fetchedKeyWords, null, 2));

                    // Merge key words into the main flashcards array
                    flashcards.forEach((card, index) => {
                        const stringKey = String(index);
                        if (fetchedKeyWords[stringKey]) {
                            console.log(`DEBUG 2: Merging key word for index ${index}`);
                            card.keyWord = fetchedKeyWords[stringKey];
                        }
                    });
                    console.log("DEBUG 3: Flashcards array *after* merge:", JSON.parse(JSON.stringify(flashcards)));
                }
            } else {
                console.log("No personal key word preset found for this set.");
                activePresetId = null;
            }
        } catch (e) {
            console.error("Error fetching personal key word preset:", e);
        }
    }

        document.getElementById("setTitle").textContent = reviewingSetData.title || "Untitled Set";
        document.getElementById("descriptionBox").textContent = reviewingSetData.description || "No description provided.";
        document.getElementById("cardCategory").textContent = reviewingSetData.category || "General";
        
        const creatorEmail = reviewingSetData.creatorEmail || reviewingSetData.user;
        if (creatorEmail) {
          const usernameRef = doc(db, "usernames", creatorEmail);
          const usernameSnap = await getDoc(usernameRef);
          if (usernameSnap.exists() && usernameSnap.data().username) {
  const creatorName = usernameSnap.data().username;
  document.getElementById("cardCreator").textContent = creatorName;
  originalSetData.creatorName = creatorName; // --- ADD THIS LINE ---
} else {
  document.getElementById("cardCreator").textContent = creatorEmail.split('@')[0];
}
        } else {
          document.getElementById("cardCreator").textContent = "N/A";
        }
// --- Code to handle displaying the first card or empty set message ---
        if (flashcards.length > 0) {
          updateCard(currentIndex); // Load the first card
        } else {
          front.textContent = "This set is empty.";
          back.textContent = "Add some cards!";
          counter.textContent = "0 / 0";
           // Disable nav buttons if empty
           [prevBtnElem, nextBtnElem, shuffleBtnElem, setKeyWordBtn].forEach(btn => {
                btn.style.opacity = "0.5";
                btn.style.pointerEvents = "none";
           });
        }
        // --- End card display/empty set handling ---

        // --- +++ Ensure controls are ENABLED (ADD THIS BLOCK) +++ ---
        [prevBtnElem, nextBtnElem, shuffleBtnElem, setKeyWordBtn].forEach(btn => {
            if (flashcards.length > 0) { // Only enable if there are cards
                 btn.style.opacity = "1";
                 btn.style.pointerEvents = "auto";
                 // Ensure original event listeners are attached (assuming they are added elsewhere, otherwise add them here)
            } else {
                 // Keep them disabled if the set is empty (redundant check, but safe)
                 btn.style.opacity = "0.5";
                 btn.style.pointerEvents = "none";
            }
        });
        modeButtons.forEach(button => {
            button.style.opacity = "1";
            button.style.cursor = "pointer";
            // Re-attach original onclick handlers dynamically
            const modeTextContent = button.textContent.trim();
            let mode = '';
            // Extract the mode name, ignoring potential "New" badges etc.
            if (modeTextContent.includes('Flashcard')) mode = 'flashcard';
            else if (modeTextContent.includes('Test')) mode = 'test';
            else if (modeTextContent.includes('Blitz')) mode = 'blitz';
            else if (modeTextContent.includes('Learn')) mode = 'learn';
            else if (modeTextContent.includes('Match')) mode = 'match';
            else if (modeTextContent.includes('DefiDrop')) mode = 'defidrop';

            const targetUrl = mode ? `${mode}.html` : '';

            if (targetUrl && typeof navigateToMode === 'function') {
                 button.onclick = () => navigateToMode(targetUrl);
            } else {
                 console.warn(`Could not set navigation for button: ${button.textContent.trim()}`);
                 button.onclick = null; // Clear if no URL or function
            }
        });

         // Make sure the correct mode button is active
         modeButtons.forEach(button => button.classList.remove('active'));
         // Find button specifically containing "Flashcard" text
         const currentModeButton = Array.from(modeButtons).find(btn => btn.textContent.includes('Flashcard'));
         if (currentModeButton) currentModeButton.classList.add('active');


        // Enable toggles
         if (performanceToggle) performanceToggle.disabled = false;
         if (reverseToggle) reverseToggle.disabled = false;

        // Show sidenav toggle
         if (sidenavToggle) sidenavToggle.style.display = 'block'; // Or 'flex' or 'inline-block' depending on CSS

        // Show correct shortcut text (ensure it's reset from placeholder)
        if (shortcutNormalText) {
             shortcutNormalText.textContent = 'Shortcut: Press Space or click on the card to flip.';
             shortcutNormalText.classList.remove('hidden');
        }
        if (shortcutPerformanceText) shortcutPerformanceText.classList.add('hidden'); // Ensure performance shortcuts hidden initially
        // --- +++ End enabling controls +++ ---
        if (flashcards.length > 0) {
          
          updateCard(currentIndex);
        } else {
          front.textContent = "This set is empty.";
          back.textContent = "Add some cards!";
        }fetchAndDisplayReviewCards();
      } else {
         document.body.innerHTML = "<h2 style='color:white; text-align:center; padding-top:100px;'>Error: Could not find this flashcard set.</h2>";
        // Handle case where ID existed but document doesn't
        console.error("Set ID found in localStorage, but document does not exist.");
        front.textContent = "Error";
        back.textContent = "Set data not found.";
        setTitleElem.textContent = "Error";
        descriptionBoxElem.textContent = "The requested flashcard set could not be found in the database.";
        categoryElem.textContent = "-"; // Clear category/creator too
        creatorElem.textContent = "-";
        counter.textContent = "0 / 0";
        // +++ Disable buttons like in the placeholder state +++
         [prevBtnElem, nextBtnElem, shuffleBtnElem, setKeyWordBtn].forEach(btn => {
            btn.style.opacity = "0.5";
            btn.style.pointerEvents = "none";
         });
         modeButtons.forEach(button => {
            button.style.opacity = "0.6";
            button.style.cursor = "not-allowed";
            button.onclick = (e) => e.preventDefault();
            button.classList.remove('active');
         });
         if (performanceToggle) performanceToggle.disabled = true;
         if (reverseToggle) reverseToggle.disabled = true;
         if (sidenavToggle) sidenavToggle.style.display = 'none';
        // +++ End disabling +++
        }
    } catch (error) {
      console.error("Error fetching flashcard set:", error);
      document.body.innerHTML = "<h2 style='color:white; text-align:center; padding-top:100px;'>An error occurred while loading the set.</h2>";
      // Display error messages without removing layout
      front.textContent = "Error Loading";
      back.textContent = "Could not load set data. Please try again.";
      setTitleElem.textContent = "Error";
      descriptionBoxElem.textContent = "An error occurred while trying to load the flashcard set.";
      categoryElem.textContent = "-"; // Clear category/creator too
      creatorElem.textContent = "-";
      counter.textContent = "0 / 0";
      // +++ Disable buttons like in the placeholder state +++
      [prevBtnElem, nextBtnElem, shuffleBtnElem, setKeyWordBtn].forEach(btn => {
        btn.style.opacity = "0.5";
        btn.style.pointerEvents = "none";
      });
      modeButtons.forEach(button => {
        button.style.opacity = "0.6";
        button.style.cursor = "not-allowed";
        button.onclick = (e) => e.preventDefault();
        button.classList.remove('active');
      });
      if (performanceToggle) performanceToggle.disabled = true;
      if (reverseToggle) reverseToggle.disabled = true;
      if (sidenavToggle) sidenavToggle.style.display = 'none';
      // +++ End disabling +++
    }
  });

  // --- Helper Functions ---
// --- Helper Functions ---
  function isImageUrl(text) { return typeof text === "string" && text.startsWith("https://") && text.includes("firebasestorage.googleapis.com"); }
// ‚ñº‚ñº‚ñº REPLACE THE setCardFace FUNCTION WITH THIS ‚ñº‚ñº‚ñº
function setCardFace(element, content, isHTML) {
    // 1. Clear the card face completely
    element.innerHTML = ''; 

    // 2. Create a new wrapper span
    const contentWrapper = document.createElement('span');

    // 3. Set the content INSIDE the new wrapper
    // This handles both image tags and highlighted text
    if (isHTML) {
        contentWrapper.innerHTML = content;
    } else {
        contentWrapper.textContent = content;
    }

    // 4. Append the wrapper as the *single* child
    // This makes it the sole flex item to be centered by the card's CSS
    element.appendChild(contentWrapper);
}
// ‚ñ≤‚ñ≤‚ñ≤ END OF REPLACED FUNCTION ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº ADD THIS HELPER FUNCTION ‚ñº‚ñº‚ñº
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
  // --- NEW: Helper function to adjust font size ---
 function getRequiredFontSize(element, checkHorizontal = false) {
    element.style.fontSize = '2rem'; // Reset font size to the default from CSS
    let currentSize = 2;

    if (checkHorizontal) {
        while (element.scrollWidth > element.clientWidth && currentSize > 0.5) {
            currentSize -= 0.1;
            element.style.fontSize = `${currentSize}rem`;
        }
    } else {
        while (element.scrollHeight > element.clientHeight && currentSize > 0.5) {
            currentSize -= 0.1;
            element.style.fontSize = `${currentSize}rem`;
        }
    }
    return currentSize; // Return the calculated size
  }
function shuffleFlashcards() {
  for (let i = flashcards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
  }
  // Reset to the first card and update the display
  currentIndex = 0;
  updateCard(currentIndex);
  
  // Show a confirmation alert
  showCustomAlert("The deck has been shuffled!");
}
  // --- REPLACE your old updateCard function with this new one ---

  // --- REPLACE your old updateCard function with this new one ---
 // ‚ñº‚ñº‚ñº REPLACE THE ENTIRE updateCard FUNCTION WITH THIS ‚ñº‚ñº‚ñº
// ‚ñº‚ñº‚ñº This is the complete function from your file, updated ‚ñº‚ñº‚ñº
function updateCard(index) {
  const cardDataForLog = flashcards[index];
    console.log(`DEBUG 4: updateCard(${index}) called.`, {
        cardData: JSON.parse(JSON.stringify(cardDataForLog)),
        keyWordFound: cardDataForLog ? cardDataForLog.keyWord : "N/A",
        reverseMode: reverseMode
    });
    // --- Stop any playing audio when the card changes ---
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }

    card.style.transition = "none";
    card.classList.remove("flipped");
    const cardData = flashcards[index];
    if (!cardData) return;

    // --- NEW: Clear ALL old icons first ---
    front.querySelectorAll('.speaker-icon').forEach(icon => icon.remove());
    back.querySelectorAll('.speaker-icon').forEach(icon => icon.remove());

    // --- NEW: Get base text and check for images ---
    let termText = cardData.term;
    let defText = cardData.definition;
    let isTermImage = isImageUrl(termText);
    let isDefImage = isImageUrl(defText);

    // --- NEW: Check for and apply key word highlighting ---
    
    // ‚ñº‚ñº‚ñº THIS IS THE UPDATED LOGIC ‚ñº‚ñº‚ñº
    
    const keyWord = cardData.keyWord; // This is now an object: { text: "...", index: ... }
    
    console.log(`DEBUG 5: Checking for highlight. Key word object is:`, keyWord ? JSON.parse(JSON.stringify(keyWord)) : "undefined");

    let definitionHasHighlight = false;

    // --- NEW LOGIC: Check for the new object structure ---
    if (keyWord && typeof keyWord === 'object' && keyWord.text && keyWord.index !== undefined && !isDefImage) {
        
        const keyWordText = keyWord.text;
        const startIndex = keyWord.index;
        const endIndex = startIndex + keyWordText.length;

        // Safety check: Does the text at that index still match?
        if (defText.substring(startIndex, endIndex) === keyWordText) {
            // It matches! Build the highlight using substring
            const beforeText = defText.substring(0, startIndex);
            const afterText = defText.substring(endIndex);
            
            defText = `${beforeText}<span class="highlighted-key-word">${keyWordText}</span>${afterText}`;
            definitionHasHighlight = true;
        } else {
            // Mismatch! The definition may have been edited.
            // Fall back to highlighting just the FIRST match (no 'g' flag).
            console.warn("Key word index mismatch. Highlighting first match.");
            const escapedKeyWord = escapeRegExp(keyWord.text);
            const regex = new RegExp(`(${escapedKeyWord})`, 'i'); // 'i' = case-insensitive, NO 'g'
            defText = defText.replace(regex, `<span class="highlighted-key-word">$1</span>`);
            definitionHasHighlight = true;
        }

    } 
    // --- FALLBACK: For old key words you saved as strings ---
    else if (keyWord && typeof keyWord === 'string' && !isDefImage) {
        console.warn("Legacy key word (string) found. Highlighting all instances.");
        const escapedKeyWord = escapeRegExp(keyWord);
        const regex = new RegExp(`(${escapedKeyWord})`, 'gi'); // 'g' for global
        if (defText.match(regex)) {
           defText = defText.replace(regex, `<span class="highlighted-key-word">$1</span>`);
           definitionHasHighlight = true;
        }
    }

    // ‚ñ≤‚ñ≤‚ñ≤ END OF UPDATED LOGIC ‚ñ≤‚ñ≤‚ñ≤


    // --- FONT SIZE CALCULATION (uses original text) ---
    // Temporarily set textContent for both sides to calculate sizes
    front.textContent = cardData.term;
    if (isDefImage) {
      back.textContent = "Image"; // Placeholder for sizing
    } else {
      back.textContent = cardData.definition; // Use original def text
    }

    // Calculate the required font size for both term and definition
    const termFontSize = getRequiredFontSize(front, true);
    const defFontSize = isDefImage ? 2 : getRequiredFontSize(back, false);

    // Use the smaller of the two font sizes for both sides
    const finalSize = Math.min(termFontSize, defFontSize);
    front.style.fontSize = `${finalSize}rem`;
    back.style.fontSize = `${finalSize}rem`;

    // --- SET FINAL CONTENT ---

    // Create image strings if needed
    let frontContent = isTermImage ? `<img src="${termText}" alt="Term Image" style="max-width:100%; max-height:100%; border-radius: 8px;" />` : termText;
    let backContent = isDefImage ? `<img src="${defText}" alt="Definition Image" style="max-width:100%; max-height:100%; border-radius: 8px;" />` : defText; // defText is already highlighted or plain

    // Apply content based on reverse mode
    if (reverseMode) {
      setCardFace(front, backContent, isDefImage || definitionHasHighlight);
      setCardFace(back, frontContent, isTermImage);
    } else {
      setCardFace(front, frontContent, isTermImage);
      setCardFace(back, backContent, isDefImage || definitionHasHighlight);
    }

    // --- NEW: Add Speaker Icons (AFTER setting content) ---

    // 1. Add icon for the TERM
    if (!isTermImage) {
        const termIcon = createSpeakerIcon(cardData.term);
        if (reverseMode) {
            back.appendChild(termIcon); // In reverse mode, term is on the back
        } else {
            front.appendChild(termIcon); // In normal mode, term is on the front
        }
    }

    // 2. Add icon for the DEFINITION
    if (!isDefImage) {
        const defIcon = createSpeakerIcon(cardData.definition);
        if (reverseMode) {
            front.appendChild(defIcon); // In reverse mode, definition is on the front
        } else {
            back.appendChild(defIcon); // In normal mode, definition is on the back
        }
    }
    // --- End of Speaker Icon Code ---

    counter.textContent = `${index + 1} / ${flashcards.length}`;
    setTimeout(() => { card.style.transition = "transform 0.3s"; }, 10);
}
  function showFeedback(type) {
    // Don't show feedback if we're in the locked "My Review Session" mode
    if (performanceToggle.disabled) return;

    if (type === 'sad') {
        feedbackText.textContent = "+1 Card for Review";
        feedbackText.className = 'floating-text sad animate';
    } else if (type === 'happy') {
        feedbackText.textContent = "‚úîÔ∏è Marked as Known";
        feedbackText.className = 'floating-text happy animate';
    }

    // Reset the animation class after it finishes
    setTimeout(() => {
        feedbackText.className = 'floating-text';
    }, 1200); // This duration must match the animation time in the CSS
}
  // --- Event Listeners ---
reverseToggle.addEventListener("change", (event) => { reverseMode = event.target.checked; updateCard(currentIndex); });
card.addEventListener("click", () => { card.classList.toggle("flipped"); });
setKeyWordBtn.addEventListener('click', () => {
    const user = auth.currentUser;
    if (!user || user.isAnonymous) {
        showCustomAlert("Please log in to set key words.");
        return;
    }

    if (!flashcards || flashcards.length === 0) {
        showCustomAlert("There are no cards in this set.");
        return;
    }

const currentCard = flashcards[currentIndex];
// Check definition based on reverse mode
const currentDef = currentCard.definition;

if (isImageUrl(currentDef)) {
    showCustomAlert("Cannot set key words for image-based content.");
    return;
}

// ‚ñº‚ñº‚ñº MODIFY THESE LINES ‚ñº‚ñº‚ñº
originalDefinitionText = currentDef; // Store the original plain text
keyWordDefinition.textContent = originalDefinitionText; // Set the initial display
// ‚ñ≤‚ñ≤‚ñ≤ END OF MODIFICATIONS ‚ñ≤‚ñ≤‚ñ≤

selectedKeyWord.textContent = "Select text above...";
keyWordModal.classList.add('visible');
});

// Close the modal with Cancel button
closeKeyWordModalBtn.addEventListener('click', () => {
    keyWordModal.classList.remove('visible');

    // ‚ñº‚ñº‚ñº ADD THESE 2 LINES TO RESET ‚ñº‚ñº‚ñº
    keyWordDefinition.textContent = originalDefinitionText;
    selectedKeyWord.textContent = "Select text above...";
});

// Close the modal by clicking overlay
// Close the modal by clicking overlay
keyWordModal.addEventListener('click', (event) => {
  if (event.target === keyWordModal) {
    keyWordModal.classList.remove('visible');

    // ‚ñº‚ñº‚ñº ADD THESE 2 LINES TO RESET ‚ñº‚ñº‚ñº
    keyWordDefinition.textContent = originalDefinitionText;
    selectedKeyWord.textContent = "Select text above...";
  }
});

// Handle text selection


// Handle text selection
// ... around line 800 ...

// Handle text selection
// ... around line 800 ...

// Handle text selection
keyWordDefinition.addEventListener('mouseup', () => {
    const selection = window.getSelection(); // Get the full Selection object
    const selectedText = selection.toString().trim(); // Get the text, trimmed

    // Check if the selection is valid and is inside our definition box
    // (selection.anchorNode is the element where the selection started)
    if (selectedText && keyWordDefinition.contains(selection.anchorNode)) {
        
        // 1. Update the "Your Key Word" box with the trimmed text
        selectedKeyWord.textContent = selectedText;

        // 2. Get the precise start/end character indexes of the selection
        // This works regardless of which direction the user selected (left-to-right or right-to-left)
        const startIndex = Math.min(selection.anchorOffset, selection.focusOffset);
        const endIndex = Math.max(selection.anchorOffset, selection.focusOffset);

        // ‚ñº‚ñº‚ñº ADD THIS LINE ‚ñº‚ñº‚ñº
        selectedKeyWordStartIndex = startIndex; // Store the index
        // ‚ñ≤‚ñ≤‚ñ≤ END OF ADDITION ‚ñ≤‚ñ≤‚ñ≤

        // 3. Re-build the HTML from the *original plain text*
        // This ensures we only highlight this single instance.
        const beforeText = originalDefinitionText.substring(0, startIndex);
        const highlightedText = originalDefinitionText.substring(startIndex, endIndex);
        const afterText = originalDefinitionText.substring(endIndex);

        // 4. Set the innerHTML to display the new highlight
        // We are NOT using a regex, so only the text at these exact indexes is wrapped
        keyWordDefinition.innerHTML = 
            `${beforeText}<span class="highlighted-key-word">${highlightedText}</span>${afterText}`;

    } else if (selectedText.length === 0) {
        // Optional: If user just clicks without dragging, reset the view
        keyWordDefinition.textContent = originalDefinitionText;
        selectedKeyWord.textContent = "Select text above...";
        
        // ‚ñº‚ñº‚ñº ADD THIS LINE ‚ñº‚ñº‚ñº
        selectedKeyWordStartIndex = -1; // Reset the index
        // ‚ñ≤‚ñ≤‚ñ≤ END OF ADDITION ‚ñ≤‚ñ≤‚ñ≤
    }
});
// Save the key word
// ... around line 830 ...

// Save the key word
saveKeyWordBtn.addEventListener('click', async () => {
    const keyWordText = selectedKeyWord.textContent;

    if (!keyWordText || keyWordText === "Select text above...") {
        showCustomAlert("Please select a key word first.");
        return;
    }
    if (selectedKeyWordStartIndex === -1 && keyWordText) {
        showCustomAlert("Error: Could not find selection index. Please re-select your key word.");
        return;
    }

    const user = auth.currentUser;
    if (!user || user.isAnonymous) {
        showCustomAlert("You must be logged in to save.");
        return;
    }

    const userEmail = user.email;
    const reviewingSetId = localStorage.getItem("reviewingSetId");
    if (!reviewingSetId) {
        showCustomAlert("Error: Could not find set ID.");
        return;
    }

    // --- NEW SAVE LOGIC FOR 'KeyWordPresets' ---
    try {
        const keyWordData = {
            text: keyWordText,
            index: selectedKeyWordStartIndex
        };

        const presetRef = collection(db, "KeyWordPresets");
        
        // 1. Check if a preset doc already exists for this user and set
        const q = query(presetRef, where("userEmail", "==", userEmail), where("setId", "==", reviewingSetId));
        const querySnap = await getDocs(q);

        // 2. Define the path to update the specific key word
        // Note: Firestore field paths with dots must use FieldPath object or dot notation in the update object.
        const fieldPath = `keyWords.${currentIndex}`;

        if (querySnap.empty) {
            // 3a. No preset exists: Create a new document
            await addDoc(presetRef, {
                userEmail: userEmail,
                setId: reviewingSetId,
                keyWords: {
                    [currentIndex]: keyWordData // Save the single key word
                }
            });
        } else {
            // 3b. Preset exists: Update the existing document
            const docId = querySnap.docs[0].id;
            const docRef = doc(db, "KeyWordPresets", docId);
            
            // Use setDoc with merge:true to create/update the nested key
            // This is safer for nested objects than updateDoc
            await setDoc(docRef, { 
                keyWords: {
                    [currentIndex]: keyWordData
                }
            }, { merge: true });
        }
        // --- END OF NEW SAVE LOGIC ---

        showCustomAlert("Key word saved successfully!");

        // Update the live flashcard object
        flashcards[currentIndex].keyWord = keyWordData;
        updateCard(currentIndex);

        keyWordModal.classList.remove('visible');
        keyWordDefinition.textContent = originalDefinitionText;
        selectedKeyWord.textContent = "Select text above...";
        selectedKeyWordStartIndex = -1; // Reset index after saving

    } catch (error) {
        console.error("Error saving key word preset:", error);
        showCustomAlert("An error occurred while saving. Please try again.");
    }
});
// --- Also add the reset to the modal close buttons ---

closeKeyWordModalBtn.addEventListener('click', () => {
    keyWordModal.classList.remove('visible');
    keyWordDefinition.textContent = originalDefinitionText;
    selectedKeyWord.textContent = "Select text above...";
    selectedKeyWordStartIndex = -1; // <-- ADD THIS
});

keyWordModal.addEventListener('click', (event) => {
  if (event.target === keyWordModal) {
    keyWordModal.classList.remove('visible');
    keyWordDefinition.textContent = originalDefinitionText;
    selectedKeyWord.textContent = "Select text above...";
    selectedKeyWordStartIndex = -1; // <-- ADD THIS
  }
});
// --- Also add the reset to the modal close buttons ---

closeKeyWordModalBtn.addEventListener('click', () => {
    keyWordModal.classList.remove('visible');
    keyWordDefinition.textContent = originalDefinitionText;
    selectedKeyWord.textContent = "Select text above...";
    selectedKeyWordStartIndex = -1; // <-- ADD THIS
});

keyWordModal.addEventListener('click', (event) => {
  if (event.target === keyWordModal) {
    keyWordModal.classList.remove('visible');
    keyWordDefinition.textContent = originalDefinitionText;
    selectedKeyWord.textContent = "Select text above...";
    selectedKeyWordStartIndex = -1; // <-- ADD THIS
  }
});
shuffleBtn.addEventListener("click", () => {
    // Prevent shuffling while in a "My Review Session"
    if (performanceToggle.disabled) {
        showCustomAlert("You cannot shuffle cards during a review session.");
        return;
    }
    shuffleFlashcards();
});
// --- Helper function to advance to the next card ---
function handleNextCard() {
    if (currentIndex < flashcards.length - 1) {
        currentIndex++;
        updateCard(currentIndex);
    }
}

// --- Helper function to save a card to Firestore for review ---
// --- Helper function to save a card to Firestore for review ---
async function recordCardForReview() {
    const user = auth.currentUser;
    if (!user || user.isAnonymous) {
        console.log("Anonymous or logged-out user. Cannot save card for review.");
        return;
    }

    const cardToReview = flashcards[currentIndex];
    if (!cardToReview) {
        console.error("Could not find card data to save.");
        return;
    }

    const isAlreadyInReview = localReviewCards.some(
        (card) => card.term === cardToReview.term && card.definition === cardToReview.definition
    );

    if (isAlreadyInReview) {
        console.log("This card is already in the review list. Skipping.");
        return;
    }

    const userEmail = user.email;
    const reviewRef = doc(db, "flashcardreview", userEmail);

    try {
        const newCardData = {
            term: cardToReview.term,
            definition: cardToReview.definition,
            fromSetId: localStorage.getItem("reviewingSetId"),
            fromSetTitle: document.getElementById("setTitle").textContent
        };

        // Now we ONLY update Firestore. The real-time listener will handle all UI and local array updates.
        await setDoc(reviewRef, {
            cardsForReview: arrayUnion(newCardData)
        }, { merge: true });

    } catch (error) {
        console.error("Error saving card for review:", error);
    }
}

// --- Helper function to REMOVE a card from the Firestore review list ---
async function removeCardFromReview() {
    const user = auth.currentUser;
    if (!user || user.isAnonymous) return; // Exit if no user

    const cardToRemove = flashcards[currentIndex];
    if (!cardToRemove) return; // Exit if there's no card data

    const reviewRef = doc(db, "flashcardreview", user.email);

    try {
        // Use updateDoc and arrayRemove to pull the specific card object from the array
        await updateDoc(reviewRef, {
            cardsForReview: arrayRemove(cardToRemove)
        });
    } catch (error) {
        console.error("Error removing card from review:", error);
    }
}

const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");

prevBtn.addEventListener("click", async () => {
    if (performanceToggle.checked) {
      showFeedback('sad');
        // PERFORMANCE MODE: The sad face was clicked ("I didn't know this card")
        // 1. Record the current card to Firestore.
        await recordCardForReview();
        // 2. Proceed to the next card.
        handleNextCard();
    } else {
        // NORMAL MODE: This is the "previous" button.
        if (currentIndex > 0) {
            currentIndex--;
            updateCard(currentIndex);
        }
    }
});

nextBtn.addEventListener('click', async () => {
    if (performanceToggle.disabled) {
        // --- This is the "My Review Session" mode logic ---
        // (No changes needed here)
        if (flashcards.length > 0 && currentIndex < flashcards.length) {
            await removeCardFromReview();
        }
        if (currentIndex >= flashcards.length && flashcards.length > 0) {
            currentIndex = flashcards.length - 1;
        }
        if (flashcards.length === 0) {
            front.textContent = "Review Complete!";
            back.textContent = "You've mastered all your review cards.";
            counter.textContent = "0 / 0";
        } else {
            updateCard(currentIndex);
        }
    } else {
        // --- This is the NORMAL mode logic ---
        if (performanceToggle.checked) {
            showFeedback('happy'); // Show happy feedback
        }
        handleNextCard(); // Always go to the next card
    }
});

document.addEventListener("keydown", (e) => {
  // Do nothing if the user is typing in an input field
  if (document.activeElement.tagName === "INPUT") return;

  if (e.key === "ArrowRight") {
    e.preventDefault();
    nextBtn.click(); // Triggers "Next" or "Knew It"
  } else if (e.key === "ArrowLeft") {
    e.preventDefault();
    prevBtn.click(); // Triggers "Previous" or "Didn't Know"
  } else if (e.key === " ") { // Check for spacebar press
    e.preventDefault(); // Prevent the page from scrolling down
    card.classList.toggle("flipped"); // Flip the card
  }
});
// --- New Performance Monitor Logic ---
const performanceToggle = document.getElementById('performanceToggle');
const prevIcon = document.querySelector('#prevBtn i');
const nextIcon = document.querySelector('#nextBtn i');

performanceToggle.addEventListener('change', (event) => {
    const isPerformanceMode = event.target.checked;

    if (isPerformanceMode) {
        prevIcon.className = 'fa-regular fa-face-frown';
        nextIcon.className = 'fa-regular fa-face-smile';
        reviewCounter.classList.add('visible');
        shortcutNormalText.classList.add('hidden');
        shortcutPerformanceText.classList.remove('hidden');
    } else {
        prevIcon.className = 'fa-solid fa-chevron-left';
        nextIcon.className = 'fa-solid fa-chevron-right';
        reviewCounter.classList.remove('visible');
        shortcutNormalText.classList.remove('hidden');
        shortcutPerformanceText.classList.add('hidden');
    }
});
// --- Review Sidenav Logic ---
const toggleSidenavBtn = document.getElementById('toggleSidenavBtn');
const reviewSidenav = document.getElementById('reviewSidenav');
const reviewCardsList = document.getElementById('reviewCardsList');
const toggleIcon = document.querySelector('#toggleSidenavBtn i');
const reviewBtn = document.getElementById('reviewBtn');
const resetReviewBtn = document.getElementById('resetReviewBtn');
let reviewDataLoaded = false;
let localReviewCards = []; // To store a local copy of review cards
// Single function to toggle the navigation panel
function toggleNav() {
    const currentWidth = reviewSidenav.style.width;
    if (currentWidth === "350px") {
        // If it's open, close it
        reviewSidenav.style.width = "0";
        toggleSidenavBtn.style.left = "0";
        toggleIcon.style.transform = "rotate(0deg)";
    } else {
        // If it's closed, open it
        reviewSidenav.style.width = "350px";
        toggleSidenavBtn.style.left = "350px";
        toggleIcon.style.transform = "rotate(180deg)";
    }
}

// Function to fetch and display cards from the 'flashcardreview' collection
// Function to fetch and display cards from the 'flashcardreview' collection
// This function now sets up a REAL-TIME listener for review cards
function fetchAndDisplayReviewCards() {
    const user = auth.currentUser;
    if (!user || user.isAnonymous) {
        reviewCardsList.innerHTML = "<p>Please log in to see your review list.</p>";
        return;
    }

    const reviewRef = doc(db, "flashcardreview", user.email);

    // Use onSnapshot to listen for real-time changes
    // Use onSnapshot to listen for real-time changes
onSnapshot(reviewRef, (docSnap) => {
    const cards = (docSnap.exists() && docSnap.data().cardsForReview) ? docSnap.data().cardsForReview : [];
    localReviewCards = cards;

    reviewCounter.textContent = `${cards.length}`; // --- THIS LINE IS NEW ---

    if (performanceToggle.disabled) {
        flashcards = cards;
    }

    if (cards.length > 0) {
        reviewCardsList.innerHTML = "";
        cards.forEach(card => {
            const cardElement = document.createElement('div');
            cardElement.className = 'review-card-item';
            cardElement.innerHTML = `
                <p class="term">${card.term}</p>
                <p class="definition">${card.definition}</p>
            `;
            reviewCardsList.appendChild(cardElement);
        });
    } else {
        reviewCardsList.innerHTML = "<p>You haven't marked any cards for review yet.</p>";
    }
}, (error) => {
    console.error("Error with real-time listener:", error);
    reviewCardsList.innerHTML = "<p>Sorry, there was an error loading your review cards.</p>";
});
    reviewDataLoaded = true; // Mark the listener as attached
}
// Attach a single event listener to the toggle button
toggleSidenavBtn.addEventListener('click', toggleNav);
keyWordSidenavBtn.addEventListener('click', () => {
    const currentWidth = keyWordSidenav.style.width;
    const keyIcon = keyWordSidenavBtn.querySelector('i'); // Get the correct icon
    if (currentWidth === "350px") {
        // If it's open, close it
        keyWordSidenav.style.width = "0";
        keyWordSidenavBtn.style.right = "0";
        keyIcon.style.transform = "rotate(0deg)"; // Use the correct icon
    } else {
        // If it's closed, open it
        keyWordSidenav.style.width = "350px";
        keyWordSidenavBtn.style.right = "350px";
        keyIcon.style.transform = "rotate(180deg)"; // Use the correct icon
        
        // Load the presets *when the panel is opened*
        loadKeyWordPresets();
    }
});

// --- Function to query and display presets ---
async function loadKeyWordPresets() {
    keyWordPresetList.innerHTML = "<p>Loading presets...</p>";
    const reviewingSetId = localStorage.getItem("reviewingSetId");
    if (!reviewingSetId) {
        keyWordPresetList.innerHTML = "<p>Error: No set loaded.</p>";
        return;
    }

    try {
        const presetRef = collection(db, "KeyWordPresets");
        // Query for ALL presets matching this set ID
        const q = query(presetRef, where("setId", "==", reviewingSetId));
        const querySnap = await getDocs(q);

        if (querySnap.empty) {
            keyWordPresetList.innerHTML = "<p>No presets found for this set. Be the first to make one!</p>";
            return;
        }

        keyWordPresetList.innerHTML = ""; // Clear "Loading..."
querySnap.forEach(doc => {
            const preset = doc.data();
            const presetDocId = doc.id; // Get the preset's document ID
            const presetElement = document.createElement('div');
            presetElement.className = 'preset-item';

            const emailSpan = document.createElement('span');
            emailSpan.className = 'preset-email';
            
            const useButton = document.createElement('button');
            useButton.className = 'preset-use-btn';

            let emailDisplay = preset.userEmail;
            const isCurrentUserPreset = auth.currentUser && auth.currentUser.email === preset.userEmail;

            // Set the email text (e.g., "You" or the email)
            if (isCurrentUserPreset) {
                emailDisplay = "You";
            }
            emailSpan.textContent = emailDisplay;
            
            // --- REPLACED LOGIC: Set button state based on global active ID ---
            if (activePresetId === presetDocId) {
                useButton.textContent = "Using";
                useButton.classList.add('active');
            } else {
                useButton.textContent = "Use Preset";
            }
            
            useButton.addEventListener('click', () => {
                if (useButton.classList.contains('active')) {
                    return;
                }
                // Pass the doc ID to the apply function
                applyKeyWordPreset(preset.keyWords, useButton, presetDocId);
            });

            presetElement.appendChild(emailSpan);
            presetElement.appendChild(useButton);
            keyWordPresetList.appendChild(presetElement);
        });

    } catch (error) {
        console.error("Error loading key word presets:", error);
        keyWordPresetList.innerHTML = "<p>Error loading presets.</p>";
    }
}

// --- Function to apply a selected preset ---
function applyKeyWordPreset(keyWordsToApply, clickedButton, presetId) { // <-- Added presetId
    if (!keyWordsToApply) {
        showCustomAlert("This preset is empty.");
        return;
    }

    activePresetId = presetId;
    // --- NEW: Reset all other 'active' buttons ---
    const allPresetButtons = keyWordPresetList.querySelectorAll('.preset-use-btn.active');
    allPresetButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.textContent = "Use Preset";
    });

    // --- NEW: Set the clicked button to 'active' ---
    if (clickedButton) {
        clickedButton.classList.add('active');
        clickedButton.textContent = "Using";
    }

    // Loop through all flashcards and apply/remove key words
    flashcards.forEach((card) => { // We don't need 'index' from the loop anymore
        const stringKey = String(card.originalIndex); // Use the card's "memory"
        if (keyWordsToApply[stringKey]) {
            card.keyWord = keyWordsToApply[stringKey]; // Apply preset
        } else {
            delete card.keyWord; // Remove any existing key word
        }
    });

    // Refresh the current card display
    updateCard(currentIndex);
    
    // Close the sidenav (and fix icon bug)
    const keyIcon = keyWordSidenavBtn.querySelector('i'); // Get the correct icon
    keyWordSidenav.style.width = "0";
    keyWordSidenavBtn.style.right = "0";
    if (keyIcon) keyIcon.style.transform = "rotate(0deg)"; // Use the correct icon
    
    showCustomAlert("Key word preset applied!");
}
// --- Event listener for the "Reset" button ---
// --- Event listener for the "Reset" button ---
resetReviewBtn.addEventListener('click', () => {
    const user = auth.currentUser;
    if (!user || user.isAnonymous) {
        alert("You must be logged in to reset your review list.");
        return;
    }

    showCustomConfirm("Are you sure you want to clear all cards from your review list? This cannot be undone.", async () => {
        const reviewRef = doc(db, "flashcardreview", user.email);
        try {
            // Now we ONLY update Firestore. The real-time listener will handle the UI.
            await setDoc(reviewRef, { cardsForReview: [] }, { merge: true });
        } catch (error) {
            console.error("Error clearing review list:", error);
            alert("There was an error clearing your list.");
        }
    });
});

// --- NEW: Helper function to manage the custom confirmation modal ---
function showCustomConfirm(message, onConfirm) {
    const confirmModal = document.getElementById('customConfirmModal');
    const confirmMessage = document.getElementById('confirmMessage');
    const confirmBtn = document.getElementById('confirmBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    confirmMessage.textContent = message;
    confirmModal.classList.remove('hidden');

    // Create one-time event listeners to prevent duplicates
    const confirmHandler = () => {
        onConfirm();
        closeHandler();
    };

    const closeHandler = () => {
        confirmModal.classList.add('hidden');
        confirmBtn.removeEventListener('click', confirmHandler);
        cancelBtn.removeEventListener('click', closeHandler);
    };

    confirmBtn.addEventListener('click', confirmHandler);
    cancelBtn.addEventListener('click', closeHandler);
}
// --- NEW: Helper function to manage a simple custom alert modal ---
function showCustomAlert(message) {
    const alertModal = document.getElementById('customAlertModal');
    const alertMessage = document.getElementById('customAlertMessage');
    const alertOkBtn = document.getElementById('customAlertOkBtn');

    alertMessage.textContent = message;
    alertModal.classList.remove('hidden');

    const closeHandler = () => {
        alertModal.classList.add('hidden');
        alertOkBtn.removeEventListener('click', closeHandler);
    };

    alertOkBtn.addEventListener('click', closeHandler);
}
// --- Event listener for the "Review" button ---
// --- Event listener for the "Review" button ---
// --- Event listener for the "Review" button ---
reviewBtn.addEventListener('click', async () => {
    const user = auth.currentUser;
    if (!user || user.isAnonymous) {
        showCustomAlert("You must be logged in to review your cards.");
        return;
    }

    const reviewRef = doc(db, "flashcardreview", user.email);
    const docSnap = await getDoc(reviewRef);

    if (docSnap.exists() && docSnap.data().cardsForReview && docSnap.data().cardsForReview.length > 0) {
        const reviewCards = docSnap.data().cardsForReview;

        flashcards = reviewCards; 
        flashcards.forEach((card, index) => {
            card.originalIndex = index;
        });
        currentIndex = 0; 

        updateCard(currentIndex); 
        document.getElementById("setTitle").textContent = "My Review Session";
        document.getElementById("descriptionBox").textContent = "Reviewing cards you found difficult.";
        document.getElementById("cardCategory").textContent = "Review";
        // --- ‚ñº‚ñº‚ñº ADD THIS LINE FOR DEBUGGING ‚ñº‚ñº‚ñº ---
        console.log("Entering Review Mode. Current user object:", user);
        // --- ‚ñ≤‚ñ≤‚ñ≤ END OF ADDED LINE ‚ñ≤‚ñ≤‚ñ≤ ---
        // Set creator to the current user's username
const usernameRef = doc(db, "usernames", user.email);
const usernameSnap = await getDoc(usernameRef);
if (usernameSnap.exists() && usernameSnap.data().username) {
    document.getElementById("cardCreator").textContent = usernameSnap.data().username;
} else {
    // Fallback to email if no username is found
    document.getElementById("cardCreator").textContent = user.email.split('@')[0];
}

        // --- ADD THESE LINES ---
        performanceToggle.checked = true; // Turn the toggle on
        performanceToggle.dispatchEvent(new Event('change')); // Trigger the icon change
        performanceToggle.disabled = true; // Disable the toggle
        // --- END OF ADDED LINES ---
exitReviewBtn.classList.remove('hidden'); // Show the exit button
        toggleNav();

    } else {
        showCustomAlert("You have no cards in your review list to study!");
    }
});
// --- New Event Listener for Back to Folders Button ---
// --- New Event Listener for Back to Folders Button ---
backToFoldersBtn.addEventListener('click', async (event) => {
    event.preventDefault(); // Prevent the link from navigating immediately

    const user = auth.currentUser;
    if (user && !user.isAnonymous) {
        const userEmail = user.email;
        const reviewRef = doc(db, "flashcardreview", userEmail);

        try {
            await setDoc(reviewRef, { cardsForReview: [] }, { merge: true });
        } catch (error) {
            console.error("Error clearing the review collection:", error);
        }
    }

    // --- ADD THIS LINE ---
    // Re-enable the toggle before leaving the page
    performanceToggle.disabled = false; 
    // --- END OF ADDED LINE ---

    // Navigate to the lobby after the operation is complete
    window.location.href = "lobby.html#Folderr";
});
// --- Event Listener for Exiting Review Mode ---
// --- Event Listener for Exiting Review Mode ---
exitReviewBtn.addEventListener('click', () => {
    // Show the custom confirmation modal first
    showCustomConfirm(
        "Exiting will clear all cards from your review list. Are you sure?",
        async () => {
            // This code runs only after the user clicks "Confirm"
            const user = auth.currentUser;
            if (user && !user.isAnonymous) {
                const reviewRef = doc(db, "flashcardreview", user.email);
                try {
                    // Clear the review list in Firestore
                    await setDoc(reviewRef, { cardsForReview: [] }, { merge: true });
                } catch (error) {
                    console.error("Error clearing review list on exit:", error);
                    // Optionally show an error alert to the user
                }
            }

            if (!originalSetData) return; // Safety check

            // 1. Restore the original flashcard data
            flashcards = originalSetData.flashcards;
            flashcards.forEach((card, index) => {
                card.originalIndex = index;
            });
            currentIndex = 0;

            // 2. Update the UI with original data
            updateCard(currentIndex);
            document.getElementById("setTitle").textContent = originalSetData.title;
            document.getElementById("descriptionBox").textContent = originalSetData.description;
            document.getElementById("cardCategory").textContent = originalSetData.category;
            document.getElementById("cardCreator").textContent = originalSetData.creatorName || originalSetData.creatorEmail.split('@')[0];

            // 3. Reset and re-enable the performance toggle
            performanceToggle.checked = false;
            performanceToggle.dispatchEvent(new Event('change'));
            performanceToggle.disabled = false;

            // 4. Hide the "Exit Review Session" button
            exitReviewBtn.classList.add('hidden');
        }
    );
});
  async function navigateToMode(modeUrl) {
  // --- ADD THIS BLOCK TO CLEAR THE REVIEW LIST ---
  const user = auth.currentUser;
  if (user && !user.isAnonymous) {
      const userEmail = user.email;
      const reviewRef = doc(db, "flashcardreview", userEmail);
      try {
          // Set the 'cardsForReview' array to be empty
          await setDoc(reviewRef, { cardsForReview: [] }, { merge: true });
      } catch (error) {
          console.error("Error clearing the review collection:", error);
      }
  }
  // --- END OF ADDED BLOCK ---

  if (currentReviewingSet) {
    localStorage.setItem("reviewingSet", JSON.stringify(currentReviewingSet));
  }
  localStorage.setItem("currentIndex", currentIndex);
  window.location.href = modeUrl;
}
window.navigateToMode = navigateToMode;
  
</script>
<script type="module">
  import { checkUserStatus } from './userstatuscheck.js';
  checkUserStatus();
</script>
<script type="module" src="presence.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    const infoBtn = document.getElementById('reverseInfoBtn');
    const infoModal = document.getElementById('reverseInfoModal');
    const closeInfoModalBtn = document.getElementById('closeReverseInfoModal');

    infoBtn.addEventListener('click', () => {
      infoModal.classList.add('visible');
    });

    closeInfoModalBtn.addEventListener('click', () => {
      infoModal.classList.remove('visible');
    });

    // Also close if the user clicks the dark background
    infoModal.addEventListener('click', (event) => {
      if (event.target === infoModal) {
        infoModal.classList.remove('visible');
      }
    });
  });
</script>

</body>
</html>