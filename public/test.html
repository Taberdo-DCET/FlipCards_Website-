<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test | FlipCards</title>
  <link rel="stylesheet" href="test.css">
  <link rel="icon" type="image/png" sizes="32x32" href="Group-100.png">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4779578721359852"
     crossorigin="anonymous"></script>
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
</head>
<body>

  <header class="shop-header">
    <div class="header-left">
        <a href="lobby.html#Folderr" class="back-button">‚Üê Back to Folders</a>
        <a href="shop.html" id="upgradeBtn" class="upgrade-button" style="display: none;">Upgrade your Plan</a>
    </div>
    <h2 class="shop-title">FlipCards.</h2>
</header>
<div id="toggleKeyWordSidenavBtn" class="sidenav-toggle-btn right">
    <i class="fa-solid fa-key"></i>
</div>
    <main class="test-main-container">
        
        <div class="meta-info">
            <div class="meta-item">
                <span>Category:</span>
                <strong id="cardCategory">General</strong>
            </div>
            <div class="meta-border"></div>
            <div class="meta-item">
                <span>Creator:</span>
                <strong id="cardCreator">N/A</strong>
            </div>
        </div>

        <div class="set-details">
            <div class="title-row">
                <div class="title-and-label">
                    <span class="title-label">Title:</span>
                    <h1 class="page-title" id="setTitle"></h1>
                </div>
                </div>
            
            <div class="reverse-mode-container">
                <button id="reverseInfoBtn" class="info-icon">?</button>
                <span>Reverse Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="reverseToggle">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="description-container">
                <div class="description-box" id="descriptionBox">Loading description...</div>
            </div>
        </div>
  
<div class="button-container">
    <button class="neumorphic-button" onclick="navigateToMode('flashcard.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>Flashcard</button>
    <button class="neumorphic-button active" onclick="navigateToMode('test.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="m10.4 12.6-2.8 2.8"></path><path d="m10.4 15.4-2.8-2.8"></path><path d="M12 18h6"></path></svg>Test</button>
    <button id="blitzButton" class="neumorphic-button" onclick="navigateToMode('blitz.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
</svg>
    Blitz
    <img src="new.png" alt="New Feature" class="new-icon">
</button>
    <button class="neumorphic-button" onclick="navigateToMode('learn.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.232 5.232a3 3 0 0 1 0 4.242L12 12.728l-3.232-3.232a3 3 0 0 1 0-4.242a3 3 0 0 1 4.242 0z"></path><path d="M12 12.728 8.768 9.496a3 3 0 0 1 0 4.242L12 17.228l3.232-3.232a3 3 0 0 1 0-4.242z"></path>
</svg>Learn</button>
    <button class="neumorphic-button" onclick="navigateToMode('match.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 7h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2z"></path><path d="M10 7V5.5a1.5 1.5 0 0 1 3 0V7"></path><path d="M14 17v1.5a1.5 1.5 0 0 1-3 0V17"></path><path d="M7 10H5.5a1.5 1.5 0 0 0 0 3H7"></path><path d="M17 14h1.5a1.5 1.5 0 0 0 0-3H17"></path></svg>Match</button>
    <button class="neumorphic-button" onclick="navigateToMode('defidrop.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"></path><path d="m19 12-7-7"></path></svg>DefiDrop</button>
</div>
  <div class="shortcut-bar">
      <i class="fa-solid fa-keyboard"></i>
      <span>Shortcut: Press</span>
      <kbd class="shortcut-key">Enter</kbd>
      <span>to submit your answer.</span>
  </div>
  <div class="card-container">
    <div class="definition-text" id="definition">
      Loading...
    </div>

<div class="input-area">
    
    <div class="input-wrapper">
      <div id="inputMirror"></div>
      
      <input type="text" id="termInput" placeholder="What is the term? Enter answer here...">
      <span id="inputSuggestion"></span>
    </div>
    <button onclick="submitAnswer()">Submit</button>
    <button id="showClueBtn" class="show-hint-button">
  <i class="fa-solid fa-search"></i> Show Clue
</button>
  </div>

  </div>
  <div class="custom-alert" id="customAlert">
  <div class="custom-alert-box">
    <p id="customAlertMessage"></p>
    <button class="neumorphic-button" onclick="closeCustomAlert()">Okay!</button>
  </div>
</div>
<div id="progressTracker" class="progress-tracker"></div>
<div id="flipTimerModal" class="flip-timer-modal hidden">
  <div class="flip-timer-header">
    <span class="flip-timer-title">üïí FlipTimer</span>
    <span class="flip-timer-close" onclick="closeFlipTimer()">&times;</span>
  </div>
  <div class="flip-timer-body">
    <label for="studyMinutes">Study Minutes:</label>
    <input type="number" id="studyMinutes" min="1" max="180" placeholder="Enter minutes...">
    <h2 id="flipTimerLabel">Ready to Focus?</h2>
    <h1 id="flipTimerClock">00:00</h1>

    <div class="flip-timer-buttons">
      <button onclick="startFlipTimer()">Start</button>
      <button onclick="resetFlipTimer()">Reset</button>
      <button onclick="skipBreak()">Skip</button>
      <button onclick="pauseFlipTimer()" id="pauseButton">‚è∏Ô∏è Pause</button>
    </div>

    <p>Breaks Taken: <span id="breakCounter">0</span></p>
    <div style="text-align: center; margin-top: 10px;">
      <button id="collapseBtn" onclick="collapseFlipTimer()" class="neumorphic-button" style="padding: 4px 12px; font-size: 12px;">‚ñ≤ Collapse</button>
    </div>
  </div>
</div>

<!-- FlipTimer Minimized View -->
<div id="flipTimerMinimized" class="hidden" style="
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 10px 16px;
  border-radius: 16px;
  font-family: 'QilkaBold';
  font-size: 16px;
  z-index: 3000;
  gap: 10px;
  align-items: center;
  box-shadow: 6px 6px 12px rgba(0,0,0,0.3), -6px -6px 12px rgba(255,255,255,0.05);
  cursor: pointer;
  border: 1px solid white;
  backdrop-filter: blur(8px);
  display: flex;
">
<span id="minBreakCounter">0</span>
  <span id="flipTimerMinClock">00:00</span>
   <button onclick="expandFlipTimer()" class="neumorphic-button" style="font-size: 12px; padding: 4px 10px;">‚ñ≤ Expand</button>
</div>

<!-- Confirm Dialog -->
<div id="flipTimerConfirm" class="flip-timer-confirm hidden">
  <div class="flip-timer-confirm-box">
    <p>Want to continue?</p>
    <div>
      <button onclick="confirmFlipTimerContinue(true)">Yes</button>
      <button onclick="confirmFlipTimerContinue(false)">No</button>
    </div>
  </div>
</div>

<!--Mistakes-->
<div class="mistake-review">
<div class="mistake-header">
    <div class="mistake-title-wrapper">
        <button id="mistakeInfoBtn" class="info-icon">?</button>
        <h2>Try Again?</h2>
    </div>
    <div>
        <button class="neumorphic-button2" onclick="reviewMistakes()">Review/Reveal Mistakes</button>
        <button class="neumorphic-button2" onclick="retryMistakes()">Retry Mode</button>
        <button class="neumorphic-button2 hidden" id="goBackBtn" onclick="goBackToNormal()">Go Back</button>
        <button class="neumorphic-button2" onclick="clearAllMistakes()">Clear Mistakes</button>
    </div>
</div>

  <div class="mistake-list" id="mistakeList">
    <!-- Mistake terms and definitions will be displayed here -->
  </div>
</div>

</main>
<div id="mistakeInfoModal" class="modal-overlay">
  <div class="modal-box info-modal-content">
    <h3>About "Try Again?"</h3>
    <p>This section helps you master the material. Your incorrect answers are saved here so you can learn from them.</p>
    <ul>
        <li><strong>Review/Reveal Mistakes:</strong> Shows a list of your incorrect answers and the correct terms.</li>
        <li><strong>Retry Mode:</strong> Starts a new quiz using only the cards you got wrong.</li>
        <li><strong>Clear Mistakes:</strong> Deletes all saved mistakes for this set.</li>
    </ul>
    <button id="closeMistakeInfoModal" class="neumorphic-button">Got it</button>
  </div>
</div>
<div id="reverseInfoModal" class="modal-overlay">
  <div class="modal-box info-modal-content">
    <i class="fa-solid fa-lightbulb modal-info-icon"></i>
    <h3>What is Reverse Mode?</h3>
    <p>Reverse Mode swaps the term and definition. You will be shown the definition first and must recall the term.</p>
    <button id="closeReverseInfoModal" class="neumorphic-button">Got it</button>
  </div>
</div>


<!-- Modal for setting a keyword/hint -->

<div id="showClueModal" class="modal-overlay">
  <div class="modal-box info-modal-content">
    <h3><i class="fa-solid fa-search" style="color: #ffcf00;"></i> Clue</h3>
    <div id="clueDisplayArea">Click "Show Clue" to see the first two letters.</div>
    <button class="neumorphic-button" id="closeShowClueBtn" style="width: 100%; margin-top: 20px;">Close</button>
  </div>
</div>
<div id="keyWordSidenav" class="sidenav right">
    <h3>Key Word Presets</h3>
    <p class="sidenav-description">
      Presets for this set, shared by other users.
    </p>
    <div id="keyWordPresetList">
        <p>Loading presets...</p>
    </div>
</div>
<script src="flipTimer.js"></script>
<script type="module">
  import { db, auth } from './firebaseinit.js';
  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
import {
    doc,
    getDoc,
    updateDoc,
    setDoc,
    arrayUnion,
    arrayRemove,
    collection,
    query,
    where,
    getDocs,
    addDoc
  } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

  // --- Global Variables ---
  let retryMode = false;
  let liveMistakeTracking = false;
  let reverseMode = false;
  let originalFlashcards = [];
  let flashcards = [];
  let currentIndex = 0;
  let currentReviewingSet = null;
  let currentAudio = null;
  let activePresetId = null;

  // --- Element References ---
  const termInput = document.getElementById("termInput");
  const defElement = document.getElementById("definition");
  const alertBox = document.getElementById("customAlert");
  const alertMsg = document.getElementById("customAlertMessage");
  const reverseToggle = document.getElementById("reverseToggle");
  const reverseInfoBtn = document.getElementById('reverseInfoBtn');
  const reverseInfoModal = document.getElementById('reverseInfoModal');
  const closeReverseInfoModalBtn = document.getElementById('closeReverseInfoModal');

// New Key Word Preset Refs
  const keyWordSidenavBtn = document.getElementById('toggleKeyWordSidenavBtn');
  const keyWordSidenav = document.getElementById('keyWordSidenav');
  const keyWordPresetList = document.getElementById('keyWordPresetList');

  // New Clue Refs
  const showClueBtn = document.getElementById('showClueBtn');
  const showClueModal = document.getElementById('showClueModal');
  const clueDisplayArea = document.getElementById('clueDisplayArea');
  const closeShowClueBtn = document.getElementById('closeShowClueBtn');
async function playGoogleAudio(textToSpeak) {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }

    const API_KEY = 'AIzaSyCynM5G8GUw3uM8pjdgQkWAsKow3ph9tCg'; // Replace with your actual key

    const apiUrl = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`;

    const requestBody = {
        input: {
            text: textToSpeak
        },
        voice: {
            languageCode: 'en-US', // Make sure this matches the voice name
            name: 'en-US-WaveNet-G' // Example voice
        },
        audioConfig: {
            audioEncoding: 'MP3'
        }
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            console.error('API Error Response:', await response.json());
            throw new Error(`Error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        currentAudio = new Audio(`data:audio/mp3;base64,${data.audioContent}`);
        currentAudio.play();

        currentAudio.onended = () => {
            currentAudio = null;
        };

    } catch (error) {
        console.error('Failed to generate audio. Check console errors (e.g., API key restrictions).', error);
        currentAudio = null;
    }
}

function createSpeakerIcon(textToSpeak) {
    const icon = document.createElement('i');
    icon.className = 'fa-solid fa-volume-high speaker-icon';

    icon.addEventListener('click', (e) => {
        e.stopPropagation();
        playGoogleAudio(textToSpeak);
    });
    return icon;
}

  // This runs when the user's login state is known
  onAuthStateChanged(auth, async (user) => {
    // --- Logic to show/hide the upgrade button ---
    if (user && !user.isAnonymous) {
      const upgradeBtn = document.getElementById('upgradeBtn');
      const userRolesRef = doc(db, "approved_emails", user.email);
      const userRolesSnap = await getDoc(userRolesRef);

      if (userRolesSnap.exists()) {
        const roles = userRolesSnap.data().role.toLowerCase();
        // Show button ONLY if user is NOT plus and NOT verified
        if (!roles.includes('plus') && !roles.includes('verified')) {
          upgradeBtn.style.display = 'inline-block';
        }
      }
    }
    // --- End of new logic ---

    // The rest of the script now runs inside the auth state listener
    const reviewingSetId = localStorage.getItem("reviewingSetId");
    const collectionName = localStorage.getItem("reviewingSetCollection");
    // +++ Get references for placeholder state +++
    const setTitleElem = document.getElementById("setTitle");
    const descriptionBoxElem = document.getElementById("descriptionBox");
    const categoryElem = document.getElementById("cardCategory");
    const creatorElem = document.getElementById("cardCreator");
    const defElement = document.getElementById("definition"); // Definition display area
    const termInput = document.getElementById("termInput"); // User input field
    const submitBtn = document.querySelector(".input-area button"); // Submit button
    const modeButtons = document.querySelectorAll(".button-container .neumorphic-button");
    const reverseToggle = document.getElementById('reverseToggle');
    const mistakeReviewSection = document.querySelector('.mistake-review');
    const mistakeButtons = mistakeReviewSection.querySelectorAll('.neumorphic-button2');
    const progressTracker = document.getElementById('progressTracker');
    const shortcutBar = document.querySelector('.shortcut-bar span'); // Assuming one main span for text
    // +++ End getting references +++

    if (!reviewingSetId || !collectionName) {
      // --- NEW: Placeholder State when no ID is found ---
      console.warn("No reviewingSetId or collectionName found in localStorage. Displaying placeholder state.");

      // Set placeholder text for info elements
      setTitleElem.textContent = "No Set Loaded";
      descriptionBoxElem.textContent = "Please return to the lobby and select a flashcard set to use Test mode.";
      categoryElem.textContent = "-";
      creatorElem.textContent = "-";

      // Set placeholder text and disable test area
      defElement.textContent = "Select a set in the lobby to start the test.";
      termInput.value = "";
      termInput.placeholder = "No set loaded...";
      termInput.disabled = true;
      submitBtn.disabled = true;
      submitBtn.style.opacity = "0.5";
      submitBtn.style.cursor = "not-allowed";

      // Update progress tracker
      progressTracker.textContent = "0 / 0";

      // Disable mode buttons
      modeButtons.forEach(button => {
        button.onclick = (e) => {
           e.preventDefault(); // Stop navigation
           // Use your existing alert function if available
           if (typeof showCustomAlert === 'function') {
               showCustomAlert("Please select a flashcard set from the lobby first.");
           } else {
               alert("Please select a flashcard set from the lobby first.");
           }
        };
        button.style.opacity = "0.6";
        button.style.cursor = "not-allowed";
        button.classList.remove('active'); // Ensure no button looks active
      });

      // Disable reverse toggle
      if (reverseToggle) reverseToggle.disabled = true;
      
      

      // Disable mistake review section
      mistakeReviewSection.style.opacity = "0.5";
      mistakeButtons.forEach(btn => {
        btn.disabled = true;
        btn.style.cursor = "not-allowed";
      });
      document.getElementById("mistakeList").innerHTML = "<p style='color: gray;'>Load a set to track mistakes.</p>";

      // Update shortcut bar
      if (shortcutBar) shortcutBar.textContent = 'Select a set in the lobby to enable shortcuts.';

      return; // Stop execution here
    }

    try {
      const setRef = doc(db, collectionName, reviewingSetId);
      const docSnap = await getDoc(setRef);

      if (docSnap.exists()) {
currentReviewingSet = docSnap.data();
        originalFlashcards = currentReviewingSet.flashcards || [];
        flashcards = [...originalFlashcards];

        // Stamp original index for preset logic
        flashcards.forEach((card, index) => {
            card.originalIndex = index;
        });

        // --- NEW: Load Key Word Presets (for highlighting) ---
        if (user && !user.isAnonymous) {
            const presetRef = collection(db, "KeyWordPresets");
            const q = query(presetRef, where("userEmail", "==", user.email), where("setId", "==", reviewingSetId));
            try {
                const querySnap = await getDocs(q);
                if (!querySnap.empty) {
                    const myPreset = querySnap.docs[0].data();
                    activePresetId = querySnap.docs[0].id; // Set the active preset
                    if (myPreset.keyWords) {
                        const fetchedKeyWords = myPreset.keyWords;

                        // ‚ñº‚ñº‚ñº ADD THIS LOG ‚ñº‚ñº‚ñº
                        console.log("DEBUG 1: Fetched Key Words Object:", JSON.parse(JSON.stringify(fetchedKeyWords)));
                        // ‚ñ≤‚ñ≤‚ñ≤ END OF LOG ‚ñ≤‚ñ≤‚ñ≤

                        // Merge key words into the main flashcards array
                        flashcards.forEach((card) => {
                            const stringKey = String(card.originalIndex); // Use originalIndex
                            if (fetchedKeyWords[stringKey]) {
                                // ‚ñº‚ñº‚ñº ADD THIS LOG ‚ñº‚ñº‚ñº
                                console.log(`DEBUG 2: Merging key word for originalIndex ${stringKey}`);
                                // ‚ñ≤‚ñ≤‚ñ≤ END OF LOG ‚ñ≤‚ñ≤‚ñ≤
                                card.keyWord = fetchedKeyWords[stringKey];
                            }
                        });
                    }
                } else {
                    activePresetId = null;
                }
            } catch (e) {
                console.error("Error fetching personal key word preset:", e);
            }
        }
        // --- END OF PRESET LOADING ---
        
        populatePageInfo(currentReviewingSet);
        
        if (flashcards.length > 0) {
            currentIndex = parseInt(localStorage.getItem("currentIndex")) || 0;
            updateTitle();
            setupDotTracker(flashcards.length);
            updateDefinition(currentIndex);
            toggleGoBackBtn(false);
            await reviewMistakes();
            // --- +++ Ensure controls are ENABLED +++ ---
        termInput.disabled = false;
        termInput.placeholder = "What is the term? Enter answer here..."; // Restore placeholder
        submitBtn.disabled = false;
        submitBtn.style.opacity = "1";
        submitBtn.style.cursor = "pointer";

        modeButtons.forEach(button => {
            button.style.opacity = "1";
            button.style.cursor = "pointer";
            // Re-attach original onclick handlers dynamically
            const modeTextContent = button.textContent.trim();
            let mode = '';
            // Extract the mode name
            if (modeTextContent.includes('Flashcard')) mode = 'flashcard';
            else if (modeTextContent.includes('Test')) mode = 'test';
            else if (modeTextContent.includes('Blitz')) mode = 'blitz';
            else if (modeTextContent.includes('Learn')) mode = 'learn';
            else if (modeTextContent.includes('Match')) mode = 'match';
            else if (modeTextContent.includes('DefiDrop')) mode = 'defidrop';

            const targetUrl = mode ? `${mode}.html` : '';

            // Use the globally defined navigateToMode function
            if (targetUrl && typeof navigateToMode === 'function') {
                 button.onclick = () => navigateToMode(targetUrl);
            } else {
                 console.warn(`Could not set navigation for button: ${button.textContent.trim()}`);
                 button.onclick = null; // Clear if no URL or function
            }
        });

         // Make sure the correct mode button is active
         modeButtons.forEach(button => button.classList.remove('active'));
         // Find button specifically containing "Test" text
         const currentModeButton = Array.from(modeButtons).find(btn => btn.textContent.includes('Test'));
         if (currentModeButton) currentModeButton.classList.add('active');


        // Enable reverse toggle
         if (reverseToggle) reverseToggle.disabled = false;
         
         

        // Enable mistake review section
         mistakeReviewSection.style.opacity = "1";
         mistakeButtons.forEach(btn => {
             btn.disabled = false;
             btn.style.cursor = "pointer";
         });

        // Restore shortcut bar text
         if (shortcutBar) shortcutBar.textContent = 'Shortcut: Press Enter to submit your answer.';
        // --- +++ End enabling controls +++ ---
        } else {
            defElement.textContent = "This set is empty.";
            
        }
      } else {
        document.body.innerHTML = "<h2 style='color:white; text-align:center;'>Error: Could not find set.</h2>";
        // Handle case where ID existed but document doesn't
        console.error("Set ID found in localStorage, but document does not exist.");
        setTitleElem.textContent = "Error";
        descriptionBoxElem.textContent = "The requested flashcard set could not be found in the database.";
        categoryElem.textContent = "-";
        creatorElem.textContent = "-";
        defElement.textContent = "Set not found.";
        termInput.disabled = true;
        submitBtn.disabled = true;
        progressTracker.textContent = "Error";
        // +++ Disable buttons like in the placeholder state +++
         modeButtons.forEach(button => {
            button.style.opacity = "0.6";
            button.style.cursor = "not-allowed";
            button.onclick = (e) => e.preventDefault();
            button.classList.remove('active');
         });
         if (reverseToggle) reverseToggle.disabled = true;
         
         mistakeReviewSection.style.opacity = "0.5";
         mistakeButtons.forEach(btn => {
             btn.disabled = true;
             btn.style.cursor = "not-allowed";
         });
         document.getElementById("mistakeList").innerHTML = "<p style='color: gray;'>Error loading set.</p>";
         if (shortcutBar) shortcutBar.textContent = 'Error loading set.';
        // +++ End disabling +++
      }
    } catch (error) {
      console.error("Error loading set:", error);
      document.body.innerHTML = "<h2 style='color:white; text-align:center;'>Error loading set.</h2>";
      // Display error messages without removing layout
      setTitleElem.textContent = "Error";
      descriptionBoxElem.textContent = "An error occurred while trying to load the flashcard set.";
      categoryElem.textContent = "-";
      creatorElem.textContent = "-";
      defElement.textContent = "Error loading set.";
      termInput.disabled = true;
      submitBtn.disabled = true;
      progressTracker.textContent = "Error";
      // +++ Disable buttons like in the placeholder state +++
      modeButtons.forEach(button => {
        button.style.opacity = "0.6";
        button.style.cursor = "not-allowed";
        button.onclick = (e) => e.preventDefault();
        button.classList.remove('active');
      });
      if (reverseToggle) reverseToggle.disabled = true;
      
      mistakeReviewSection.style.opacity = "0.5";
      mistakeButtons.forEach(btn => {
          btn.disabled = true;
          btn.style.cursor = "not-allowed";
      });
      document.getElementById("mistakeList").innerHTML = "<p style='color: gray;'>Error loading set.</p>";
      if (shortcutBar) shortcutBar.textContent = 'Error loading set.';
      // +++ End disabling +++
    }
  });
// --- ADD THIS ENTIRE FUNCTION ---
  async function navigateToMode(modeUrl) {
    // This function will handle navigating to other game modes.
    // We can add logic here later if needed, e.g., to save progress.
    window.location.href = modeUrl;
  }
  async function populatePageInfo(setData) {
    document.getElementById("setTitle").textContent = setData.title || "Untitled Set";
    document.getElementById("descriptionBox").textContent = setData.description || "No description provided.";
    document.getElementById("cardCategory").textContent = setData.category || "General";
    
    const creatorEmail = setData.creatorEmail || setData.user;
    if (creatorEmail) {
      const usernameRef = doc(db, "usernames", creatorEmail);
      const usernameSnap = await getDoc(usernameRef);
      if (usernameSnap.exists() && usernameSnap.data().username) {
        document.getElementById("cardCreator").textContent = usernameSnap.data().username;
      } else {
        document.getElementById("cardCreator").textContent = creatorEmail.split('@')[0];
      }
    } else {
      document.getElementById("cardCreator").textContent = "N/A";
    }
  }
// --- NEW: "Show Clue" Functions ---
  // --- NEW: "Show Clue" Functions ---
// --- NEW: "Show Clue" Functions ---
 // --- NEW: "Show Clue" Functions ---
  function showClue() {
    if (!flashcards[currentIndex]) return;

    const card = flashcards[currentIndex];
    const correctAnswer = reverseMode ? card.definition : card.term;

    // 1. Split the answer by any non-word character (like spaces, -, /)
    //    but KEEP the delimiters.
    const parts = correctAnswer.split(/(\W+)/).filter(Boolean); // filter(Boolean) removes empty strings

    // 2. Process each part
    const clueParts = parts.map(part => {
      // Check if the part is a "word" (letters or numbers)
      const isWord = /\w+/.test(part);

      // If it's NOT a word (e.g., it's a " ", "-", "/"), reveal it completely.
      if (!isWord) {
        return part;
      }

      // If it IS a word and is short (2 letters or less), reveal it completely
      // This handles short words like "at", "is", "a"
      if (part.length <= 2) {
        return part;
      }
      
      // If it's a longer word, reveal the first 2 letters
      const firstTwo = part.substring(0, 2);
      const underscores = "_".repeat(part.length - 2);
      
      return firstTwo + underscores;
    });

    // 3. Join the parts back together (with no extra spaces)
    const finalClue = clueParts.join('');

    // 4. Display the final clue
    clueDisplayArea.textContent = finalClue;
    showClueModal.style.display = 'flex';
  }

  function closeClueModal() {
    showClueModal.style.display = 'none';
  }

  // --- NEW: Key Word Preset Sidenav Functions ---
  keyWordSidenavBtn.addEventListener('click', () => {
    const currentWidth = keyWordSidenav.style.width;
    const keyIcon = keyWordSidenavBtn.querySelector('i');
    if (currentWidth === "350px") {
        keyWordSidenav.style.width = "0";
        keyWordSidenavBtn.style.right = "0";
        if (keyIcon) keyIcon.style.transform = "rotate(0deg)";
    } else {
        keyWordSidenav.style.width = "350px";
        keyWordSidenavBtn.style.right = "350px";
        if (keyIcon) keyIcon.style.transform = "rotate(180deg)";
        loadKeyWordPresets();
    }
  });

  async function loadKeyWordPresets() {
    keyWordPresetList.innerHTML = "<p>Loading presets...</p>";
    const reviewingSetId = localStorage.getItem("reviewingSetId");
    if (!reviewingSetId) {
        keyWordPresetList.innerHTML = "<p>Error: No set loaded.</p>";
        return;
    }
    try {
        const presetRef = collection(db, "KeyWordPresets");
        const q = query(presetRef, where("setId", "==", reviewingSetId));
        const querySnap = await getDocs(q);

        if (querySnap.empty) {
            keyWordPresetList.innerHTML = "<p>No presets found for this set.</p>";
            return;
        }

        keyWordPresetList.innerHTML = ""; // Clear "Loading..."
        querySnap.forEach(doc => {
            const preset = doc.data();
            const presetDocId = doc.id;
            const presetElement = document.createElement('div');
            presetElement.className = 'preset-item';

            const emailSpan = document.createElement('span');
            emailSpan.className = 'preset-email';
            const useButton = document.createElement('button');
            useButton.className = 'preset-use-btn';

            let emailDisplay = preset.userEmail;
            const isCurrentUserPreset = auth.currentUser && auth.currentUser.email === preset.userEmail;

            if (isCurrentUserPreset) emailDisplay = "You";
            emailSpan.textContent = emailDisplay;
            
            if (activePresetId === presetDocId) {
                useButton.textContent = "Using";
                useButton.classList.add('active');
            } else {
                useButton.textContent = "Use Preset";
            }
            
            useButton.addEventListener('click', () => {
                if (useButton.classList.contains('active')) return;
                applyKeyWordPreset(preset.keyWords, useButton, presetDocId);
            });

            presetElement.appendChild(emailSpan);
            presetElement.appendChild(useButton);
            keyWordPresetList.appendChild(presetElement);
        });
    } catch (error) {
        console.error("Error loading key word presets:", error);
        keyWordPresetList.innerHTML = "<p>Error loading presets.</p>";
    }
  }

  function applyKeyWordPreset(keyWordsToApply, clickedButton, presetId) {
    activePresetId = presetId; // Set the new active ID

    // Reset all other buttons
    const allPresetButtons = keyWordPresetList.querySelectorAll('.preset-use-btn.active');
    allPresetButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.textContent = "Use Preset";
    });

    // Set the clicked button to 'active'
    if (clickedButton) {
        clickedButton.classList.add('active');
        clickedButton.textContent = "Using";
    }

    // Loop through all flashcards and apply/remove key words
    flashcards.forEach((card) => {
        const stringKey = String(card.originalIndex); // Use the card's originalIndex
        if (keyWordsToApply && keyWordsToApply[stringKey]) {
            card.keyWord = keyWordsToApply[stringKey]; // Apply preset
        } else {
            delete card.keyWord; // Remove any existing key word
        }
    });

    // Refresh the current card display to show new highlights
    updateDefinition(currentIndex);
    
    // Close the sidenav
    const keyIcon = keyWordSidenavBtn.querySelector('i');
    keyWordSidenav.style.width = "0";
    keyWordSidenavBtn.style.right = "0";
    if (keyIcon) keyIcon.style.transform = "rotate(0deg)";
    
    showCustomAlert("Key word preset applied!");
  }
  // --- All original Test Mode functions remain below ---
  // --- Sidebar & Hint Functions ---
  function isImageUrl(text) { return typeof text === "string" && text.startsWith("https://") && text.includes("firebasestorage.googleapis.com"); }
  // ‚ñº‚ñº‚ñº ADD THIS NEW FUNCTION ‚ñº‚ñº‚ñº
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
  }
  // ‚ñ≤‚ñ≤‚ñ≤ END OF NEW FUNCTION ‚ñ≤‚ñ≤‚ñ≤
  function updateTitle() {
    const titleText = retryMode ? "Retry Mode: Mistakes Only" : currentReviewingSet.title || "Flashcard Quiz";
    document.getElementById('setTitle').textContent = titleText;
  }
function normalizeString(str) {
    if (typeof str !== 'string') return '';
    return str
      .toLowerCase()
      .replace(/[^a-z0-9]/g, ''); // This regex removes anything that is NOT a letter or number
  }
function updateDefinition(index) {
    if (document.getElementById("inputSuggestion")) document.getElementById("inputSuggestion").textContent = '';
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }
    defElement.innerHTML = ''; // Clear old content

    const card = flashcards[index];
    if (!card) {
        defElement.textContent = "All done!";
        updateDotTracker(index, flashcards.length);
        return;
    }

    let textToShow = reverseMode ? card.term : card.definition;
    const textToSpeak = textToShow;
    const definitionIsImage = isImageUrl(textToShow);

    // --- NEW: Key Word Highlighting Logic ---
    const keyWord = card.keyWord; // This is the object { text: "...", index: ... }

    // ‚ñº‚ñº‚ñº ADD THIS LOG ‚ñº‚ñº‚ñº
    console.log(`DEBUG 3: updateCard(index ${index}). KeyWord is:`, keyWord);
    // ‚ñ≤‚ñ≤‚ñ≤ END OF LOG ‚ñ≤‚ñ≤‚ñ≤

    let definitionHasHighlight = false;

        if (keyWord && typeof keyWord === 'object' && keyWord.text && keyWord.index !== undefined && !definitionIsImage && !reverseMode) {
            const keyWordText = keyWord.text;
            const startIndex = keyWord.index;
            const endIndex = startIndex + keyWordText.length;

            if (textToShow.substring(startIndex, endIndex) === keyWordText) {
                // It matches! Build the highlight using substring
                const beforeText = textToShow.substring(0, startIndex);
                const afterText = textToShow.substring(endIndex);
                textToShow = `${beforeText}<span class="highlighted-key-word">${keyWordText}</span>${afterText}`;
                definitionHasHighlight = true;
                
            } else {
                // ‚ñº‚ñº‚ñº ADD THIS FALLBACK BLOCK ‚ñº‚ñº‚ñº
                // Mismatch! The definition may have been edited.
                // Fall back to highlighting just the FIRST match (no 'g' flag).
                console.warn("Key word index mismatch. Highlighting first match.");
                const escapedKeyWord = escapeRegExp(keyWord.text);
                const regex = new RegExp(`(${escapedKeyWord})`, 'i'); // 'i' = case-insensitive, NO 'g'
                if (textToShow.match(regex)) {
                  textToShow = textToShow.replace(regex, `<span class="highlighted-key-word">$1</span>`);
                  definitionHasHighlight = true;
                }
                // ‚ñ≤‚ñ≤‚ñ≤ END OF FALLBACK BLOCK ‚ñ≤‚ñ≤‚ñ≤
            }
        }
        // --- END of Highlighting Logic ---

    if (definitionIsImage) {
        const img = document.createElement('img');
        img.src = textToShow;
        img.alt = "Definition Image";
        defElement.appendChild(img);
    } else {
        if (definitionHasHighlight) {
            defElement.innerHTML = textToShow; // Use innerHTML to render the span
        } else {
            defElement.textContent = textToShow; // Use textContent for plain text
        }
        defElement.appendChild(createSpeakerIcon(textToSpeak));
    }
    updateDotTracker(index, flashcards.length);
  }
  async function saveMistakeToFirebase(card) {
    const user = auth.currentUser; if (!user) return;
    const title = currentReviewingSet.title || "Untitled Set";
    const docRef = doc(db, "mistakes", user.uid);
    await setDoc(docRef, { email: user.email, sets: { [title]: arrayUnion(card) } }, { merge: true });
  }

  async function removeMistakeFromFirebase(card) {
    const user = auth.currentUser; if (!user) return;
    const title = currentReviewingSet.title || "Untitled Set";
    const docRef = doc(db, "mistakes", user.uid);
    await updateDoc(docRef, { [`sets.${title}`]: arrayRemove(card) });
  }

  async function clearAllMistakes() {
    const user = auth.currentUser; if (!user) return;
    const title = currentReviewingSet.title || "Untitled Set";
    const docRef = doc(db, "mistakes", user.uid);
    await updateDoc(docRef, { [`sets.${title}`]: [] });
    document.getElementById("mistakeList").innerHTML = "<p style='color: gray;'>No mistakes so far!</p>";
    showCustomAlert("üóëÔ∏è All mistakes cleared.");
  }

  function toggleGoBackBtn(show) {
    document.getElementById("goBackBtn")?.classList.toggle("hidden", !show);
  }

async function submitAnswer() {
   if (document.getElementById("inputSuggestion")) document.getElementById("inputSuggestion").textContent = '';
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }

    const input = termInput.value.trim();
    if (!input || !flashcards[currentIndex]) return;
    const currentCard = flashcards[currentIndex];

    // ‚ñº‚ñº‚ñº MODIFIED LOGIC ‚ñº‚ñº‚ñº
const correctAnswer = reverseMode ? currentCard.definition : currentCard.term;

    // --- START OF CHANGES ---
    // We now use the normalizeString function on both the input and the answer
    const normalizedInput = normalizeString(input);
    const normalizedAnswer = normalizeString(correctAnswer);

    const isCorrect = normalizedInput === normalizedAnswer && normalizedInput !== '';
    // --- END OF CHANGES ---
    // ‚ñ≤‚ñ≤‚ñ≤ END OF MODIFIED LOGIC ‚ñ≤‚ñ≤‚ñ≤

    if (isCorrect) {
        showCustomAlert("‚úÖ Correct!");
        if (typeof addXP === "function") addXP(100);
        if (retryMode) {
            await removeMistakeFromFirebase(currentCard);
            flashcards.splice(currentIndex, 1);
            if (liveMistakeTracking) await reviewMistakes();
            if (flashcards.length === 0) {
                await clearAllMistakes();
                showCustomAlert("üéâ All mistakes corrected!");
                // Prevent further action if the list is empty
                defElement.textContent = "All mistakes corrected!";
                termInput.value = "";
                termInput.disabled = true; // Disable input
                document.querySelector('.input-area button').disabled = true; // Disable button
                updateDotTracker(-1, 0); // Clear tracker
                return; // Stop execution here
            }
            // Adjust index if we removed the last item but there are still items left
            if (currentIndex >= flashcards.length && flashcards.length > 0) {
              currentIndex = 0; // Go back to the start or handle as appropriate
            }
        } else {
             currentIndex = (currentIndex + 1 >= flashcards.length) ? 0 : currentIndex + 1;
        }
    } else {
        // ‚ñº‚ñº‚ñº MODIFIED LOGIC ‚ñº‚ñº‚ñº
        showCustomAlert(`‚ùå Incorrect.<br>Correct answer: <strong>${correctAnswer}</strong>`);
        // ‚ñ≤‚ñ≤‚ñ≤ END OF MODIFIED LOGIC ‚ñ≤‚ñ≤‚ñ≤
        await saveMistakeToFirebase({ ...currentCard, userAnswer: input });
        if (liveMistakeTracking) await reviewMistakes();
         currentIndex = (currentIndex + 1 >= flashcards.length) ? 0 : currentIndex + 1;
    }
    termInput.value = "";
    localStorage.setItem("currentIndex", currentIndex);
    // Only update if there are still cards
    if (flashcards.length > 0) {
        updateDefinition(currentIndex);
        setupDotTracker(flashcards.length); // Update tracker based on potentially reduced list
    }
}
  function showCustomAlert(message) {
    alertMsg.innerHTML = message;
    alertBox.style.display = "flex";
  }

  function closeCustomAlert() { 
  alertBox.style.display = "none"; 
  termInput.focus(); // Add this line to refocus the input field
}

  async function reviewMistakes() {
    console.log("1. 'reviewMistakes' button clicked."); // Log when the function starts
    liveMistakeTracking = true;
    const list = document.getElementById("mistakeList");
    const user = auth.currentUser;

    if (!user) {
      console.error("Error: User is not logged in."); // Log error if no user
      list.innerHTML = "<p style='color: gray;'>You must be logged in to see mistakes.</p>";
      return;
    }

    const title = currentReviewingSet.title || "Untitled Set";
    console.log("2. Fetching mistakes for set titled:", title); // Log the set title being queried

    const docRef = doc(db, "mistakes", user.uid);
    
    try {
      const snap = await getDoc(docRef);
      console.log("3. Firebase document snapshot received:", snap); // Log the raw snapshot from Firebase

      if (!snap.exists()) {
        console.warn("Warning: Mistakes document does not exist for this user."); // Warn if the document is missing
        list.innerHTML = "<p style='color: gray;'>No mistakes document found.</p>";
        return;
      }

      const allSets = snap.data().sets || {};
      const mistakeSet = allSets[title] || [];
      console.log("4. Extracted mistakes for this specific set:", mistakeSet); // Log the array of mistakes for the current set

      if (mistakeSet.length === 0) {
        console.log("5. No mistakes found for this set. Displaying default message."); // Log when the mistake list is empty
        list.innerHTML = "<p style='color: gray;'>No mistakes so far!</p>";
        return;
      }
      
      console.log("6. Processing and counting mistakes...");
      const counts = {};
      mistakeSet.forEach(card => {
        const key = card.term;
        if (!counts[key]) counts[key] = { ...card, count: 1 };
        else counts[key].count += 1;
      });
      console.log("7. Processed mistakes with counts:", counts); // Log the final grouped/counted mistakes object
      
      console.log("8. Rendering HTML to display the mistakes.");
      list.innerHTML = Object.values(counts).map(card => `
        <div class="mistake-item">
          <div class="term">${card.term} <span style="font-size:12px; color:goldenrod;">mistakes: ${card.count}</span></div>
          <div class="definition"><strong>Correct:</strong> ${card.definition}</div>
          <div class="definition"><strong>Your answer:</strong> ${card.userAnswer || 'N/A'}</div>
        </div>
      `).join('');

    } catch (error) {
      console.error("An error occurred while fetching or processing mistakes:", error); // Catch and log any unexpected errors
    }
  }

  async function retryMistakes() {
if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }

    const user = auth.currentUser; if (!user) return;
    const title = currentReviewingSet.title || "Untitled Set";
    const docRef = doc(db, "mistakes", user.uid);
    const snap = await getDoc(docRef);
    if (!snap.exists() || !snap.data().sets || !snap.data().sets[title] || !snap.data().sets[title].length) {
      alert("No mistakes to retry."); return;
    }
    retryMode = true;
    toggleGoBackBtn(true);
    flashcards = [...snap.data().sets[title]];
    currentIndex = 0;
    updateTitle();
    setupDotTracker(flashcards.length);
    updateDefinition(currentIndex);
    showCustomAlert("üîÅ Retry Mode Loaded!");
  }

  function goBackToNormal() {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }
    retryMode = false;
    toggleGoBackBtn(false);
    flashcards = [...originalFlashcards];
    currentIndex = 0;
    updateTitle();
    setupDotTracker(flashcards.length);
    updateDefinition(currentIndex);
    showCustomAlert("‚Ü©Ô∏è Back to Normal Mode.");
  }

  function setupDotTracker(total) {
    // This function now just calls the update function to show the initial state.
    updateDotTracker(currentIndex, total);
  }

  function updateDotTracker(currentIndex, total) {
    const container = document.getElementById("progressTracker");
    if (total > 0 && container) {
      // Sets the text to show the current card number and the total.
      container.textContent = `${currentIndex + 1} / ${total}`;
    } else if (container) {
      container.textContent = ""; // Clear text if no cards
    }
  }

  termInput.addEventListener("keypress", e => { if (e.key === "Enter") { e.preventDefault(); submitAnswer(); } });
termInput.addEventListener("input", () => {
    const suggestionSpan = document.getElementById("inputSuggestion");
    const mirror = document.getElementById("inputMirror"); // ‚óÑ‚óÑ‚óÑ NEW
    
    // Exit if elements don't exist or no card is loaded
    if (!flashcards[currentIndex] || !suggestionSpan || !mirror) return;

    const currentInput = termInput.value;

    // --- Start of new positioning logic ---
    
    // 1. Update the mirror's text so we can measure it
    mirror.textContent = currentInput; 
    
    // 2. Measure the rendered width of the mirror text
    const textWidth = mirror.offsetWidth; 
    
    // 3. Set the 's' position: (input's left padding) + (text width) + (small gap)
    // We hard-code '15' because it matches the 'left: 15px' in the CSS
    suggestionSpan.style.left = (15 + textWidth + 2) + 'px'; 

    // --- End of new positioning logic ---

    // Get the current correct answer
    const currentCard = flashcards[currentIndex];
    const correctAnswer = reverseMode ? currentCard.definition : currentCard.term;

    // Normalize both
    const normalizedInput = normalizeString(currentInput);
    const normalizedAnswer = normalizeString(correctAnswer);

    // Check for the "plural" case
    if (normalizedAnswer === normalizedInput + 's' && normalizedInput !== '') {
      suggestionSpan.textContent = 's';
    } else {
      suggestionSpan.textContent = '';
    }
  });
  document.addEventListener('keydown', function(event) {
  // Checks if the alert is visible and the Enter key was pressed
  if (alertBox.style.display === 'flex' && event.key === 'Enter') {
    // Prevents any default browser action for the Enter key
    event.preventDefault(); 
    
    // Calls our updated function to close the alert and refocus
    closeCustomAlert(); 
  }
});
reverseToggle.addEventListener("change", (event) => { 
      reverseMode = event.target.checked; 
      updateDefinition(currentIndex); 
  });

  reverseInfoBtn.addEventListener('click', () => {
    reverseInfoModal.style.display = 'flex';
  });

  closeReverseInfoModalBtn.addEventListener('click', () => {
    reverseInfoModal.style.display = 'none';
  });

  reverseInfoModal.addEventListener('click', (event) => {
    if (event.target === reverseInfoModal) {
      reverseInfoModal.style.display = 'none';
    }
  });
// --- New "Show Clue" Listeners ---
  showClueBtn.addEventListener('click', showClue);
  closeShowClueBtn.addEventListener('click', closeClueModal);
  showClueModal.addEventListener('click', (event) => {
    if (event.target === showClueModal) { closeClueModal(); }
  });
  // Make functions available to HTML onclick attributes
  window.submitAnswer = submitAnswer;
  window.closeCustomAlert = closeCustomAlert;
  window.reviewMistakes = reviewMistakes;
  window.retryMistakes = retryMistakes;
  window.goBackToNormal = goBackToNormal;
  window.clearAllMistakes = clearAllMistakes;
  window.navigateToMode = navigateToMode;

window.showClue = showClue;
  window.closeClueModal = closeClueModal;
</script>
<script type="module" src="xpTracker.js"></script>








<script type="module">
  import { checkUserStatus } from './userstatuscheck.js';
  checkUserStatus();
</script>
<script type="module" src="presence.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    const infoBtn = document.getElementById('mistakeInfoBtn');
    const infoModal = document.getElementById('mistakeInfoModal');
    const closeInfoModalBtn = document.getElementById('closeMistakeInfoModal');

    infoBtn.addEventListener('click', () => {
      infoModal.style.display = 'flex';
    });

    closeInfoModalBtn.addEventListener('click', () => {
      infoModal.style.display = 'none';
    });

    // Also close if the user clicks the dark background
    infoModal.addEventListener('click', (event) => {
      if (event.target === infoModal) {
        infoModal.style.display = 'none';
      }
    });
  });
</script>
<script src="protect.js"></script>
</body>
</html>
