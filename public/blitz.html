<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blitz | FlipCards</title>
    <link rel="stylesheet" href="blitz.css">
    <link rel="icon" type="image/png" sizes="32x32" href="Group-100.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4779578721359852"
     crossorigin="anonymous"></script>
</head>
<body>
    <header class="shop-header">
        <div class="header-left">
            <a href="lobby.html#Folderr" class="back-button">← Back to Folders</a>
            <a href="shop.html" id="upgradeBtn" class="upgrade-button" style="display: none;">Upgrade your Plan</a>
        </div>
        <h2 class="shop-title">FlipCards.</h2>
    </header>

    <main class="blitz-main-container">
        <div class="meta-info">
    <div class="meta-item">
        <span>Category:</span>
        <strong id="cardCategory">General</strong>
    </div>
    <div class="meta-border"></div>
    <div class="meta-item">
        <span>Creator:</span>
        <strong id="cardCreator">N/A</strong>
    </div>
</div>

<div class="set-details">
    <div class="title-row">
        <div class="title-and-label">
            <span class="title-label">Title:</span>
            <h1 class="page-title" id="setTitle"></h1>
        </div>
    </div>
    <div class="description-container">
        <div class="description-box" id="descriptionBox">Loading description...</div>
    </div>
</div>
        <div class="button-container">
            <button class="neumorphic-button" onclick="location.href='flashcard.html'"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>Flashcard</button>
            <button class="neumorphic-button" onclick="location.href='test.html'"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="m10.4 12.6-2.8 2.8"></path><path d="m10.4 15.4-2.8-2.8"></path><path d="M12 18h6"></path></svg>Test</button>
            <button id="blitzButton" class="neumorphic-button active"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
</svg>
    Blitz
    <img src="new.png" alt="New Feature" class="new-icon">
</button>
            <button class="neumorphic-button" onclick="location.href='learn.html'"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.232 5.232a3 3 0 0 1 0 4.242L12 12.728l-3.232-3.232a3 3 0 0 1 0-4.242a3 3 0 0 1 4.242 0z"></path><path d="M12 12.728 8.768 9.496a3 3 0 0 1 0 4.242L12 17.228l3.232-3.232a3 3 0 0 1 0-4.242z"></path>
</svg>Learn</button>
            <button class="neumorphic-button" onclick="location.href='match.html'"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 7h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2z"></path><path d="M10 7V5.5a1.5 1.5 0 0 1 3 0V7"></path><path d="M14 17v1.5a1.5 1.5 0 0 1-3 0V17"></path><path d="M7 10H5.5a1.5 1.5 0 0 0 0 3H7"></path><path d="M17 14h1.5a1.5 1.5 0 0 0 0-3H17"></path></svg>Match</button>
            <button class="neumorphic-button" onclick="location.href='defidrop.html'"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"></path><path d="m19 12-7-7"></path></svg>DefiDrop</button>
        </div>
<div class="info-bar-container">
    <button id="howToBtn" class="info-icon-btn" title="How to Play">?</button>
    <div class="shortcut-bar">
        <i class="fa-solid fa-keyboard"></i>
        <span>Use </span>
        <kbd class="shortcut-key">←</kbd>
        <span> for False and </span>
        <kbd class="shortcut-key">→</kbd>
        <span> for True.</span>
    </div>
</div>
<div id="startScreen" class="custom-modal">
    <div class="modal-content success">
        <div class="modal-message">
            <h2 style="margin-top: 0; font-size: 2rem;">Blitz Mode</h2>
            <p>A term and a definition will appear. Decide if they match correctly. Answer as quickly as you can!</p>
        </div>
        <div class="modal-buttons">
            <!-- This button's text is changed to "Loading..." initially -->
<button id="startGameBtn" class="neumorphic-button" disabled>Loading...</button>
        </div>
    </div>
</div>

        <div id="gameContainer" class="blitz-container hidden">
            <div class="top-bar">
    <div id="timer" class="timer-display">00:00</div>
    <button id="retryBtn" class="icon-btn" title="Restart Game">
        <i class="fas fa-sync-alt"></i>
    </button>
</div>
            <div class="blitz-content">
                <div id="blitzStatement">
                    </div>
            </div>
            <div class="blitz-buttons">
    <button id="falseBtn" class="blitz-btn false-btn"><i class="fas fa-times"></i> False</button>
    <button id="trueBtn" class="blitz-btn true-btn"><i class="fas fa-check"></i> True</button>
</div>
        </div>
        
        <div id="resultsScreen" class="custom-modal hidden">
            <div class="modal-content success"> <div class="modal-message">
                    <h2 style="margin-top: 0; font-size: 2rem;">Game Over!</h2>
                    <p id="finalScore" style="font-size: 1.2rem; margin-bottom: 8px;"></p>
                    <p id="timeTaken" style="font-size: 1.2rem; margin: 0;"></p>
                </div>
                <div class="modal-buttons">
                    <button id="playAgainBtn" class="neumorphic-button">Play Again</button>
                    <a href="lobby.html#Folderr" class="neumorphic-button">Back to Folders</a>
                </div>
            </div>
        </div>
        
        <div class="progress-container">
    <div class="save-progress-toggle">
        <label for="saveProgressCheckbox">Save Progress</label>
        <label class="switch">
            <input type="checkbox" id="saveProgressCheckbox">
            <span class="slider round"></span>
        </label>
    </div>
    <div id="progressTracker" class="progress-tracker"></div>
</div>
    </main>
<div id="howToModal" class="custom-modal hidden">
    <div class="modal-content success">
        <div class="modal-message">
            <div class="modal-header-sticky">
                <h2 style="margin-top: 0; font-size: 2rem;">How to Play Blitz</h2>
                <p style="text-align: left; font-size: 1rem; margin-bottom: 0;">
                    Welcome to Blitz Mode! Here’s how it works:
                </p>
            </div>
            <div class="modal-body-scrollable">
                <div style="text-align: left; line-height: 1.6; font-size: 1rem;">
                    <strong>1. The Goal:</strong> A term and a definition will appear. Your job is to decide if the definition correctly matches the term.
                    <br><br>
                    <strong>2. Answering:</strong> Use the "True" and "False" buttons, or use the <kbd class="shortcut-key">→</kbd> and <kbd class="shortcut-key">←</kbd> arrow keys for faster responses.
                    <br><br>
                    <strong>3. Scoring:</strong> Answer as many cards as you can. Your final score is based on the number of correct answers.
                    <br><br>
                    <strong>4. Timer:</strong> A timer will track how long it takes you to complete the set. Try to beat your best time!
                    <br><br>
                    <strong>5. Save Progress:</strong> Check the 'Save Progress' box below the game to save your session. If you leave and come back, you'll have the option to resume where you left off!
                </div>
            </div>
        </div>
        <div class="modal-buttons">
            <button id="closeHowToModalBtn" class="neumorphic-button">Got It!</button>
        </div>
    </div>
</div>
    <script type="module">
    import { db, auth } from './firebaseinit.js';
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
import { doc, getDoc, setDoc, updateDoc, deleteField, collection, addDoc, serverTimestamp, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

    // --- DOM Elements ---
    const startScreen = document.getElementById('startScreen');
    const gameContainer = document.getElementById('gameContainer');
    const resultsScreen = document.getElementById('resultsScreen');
    const startGameBtn = document.getElementById('startGameBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const trueBtn = document.getElementById('trueBtn');
    const falseBtn = document.getElementById('falseBtn');
    const blitzStatement = document.getElementById('blitzStatement');
    const progressTracker = document.getElementById('progressTracker');
    const timerDisplay = document.getElementById('timer');
    const finalScore = document.getElementById('finalScore');
    const timeTaken = document.getElementById('timeTaken');
    const retryBtn = document.getElementById('retryBtn');
    const saveProgressCheckbox = document.getElementById('saveProgressCheckbox');
    
    // --- Game State Variables ---
    let originalFlashcards = [];
    let questions = [];
    let currentIndex = 0;
    let score = 0;
    let timerInterval;
    let startTime;

    // ▼▼▼ NEW HELPER FUNCTION TO CHECK FOR IMAGES ▼▼▼
    function isImageUrl(text) {
        return typeof text === "string" && text.startsWith("https://") && text.includes("firebasestorage.googleapis.com");
    }

    // --- Main Logic ---
    // blitz.html -> <script>

// ▼▼▼ REPLACE THE ENTIRE onAuthStateChanged FUNCTION WITH THIS ▼▼▼
onAuthStateChanged(auth, async (user) => {
    const reviewingSetId = localStorage.getItem("reviewingSetId");
    const collectionName = localStorage.getItem("reviewingSetCollection");

    if (user && !user.isAnonymous) {
        const upgradeBtn = document.getElementById('upgradeBtn');
        const userRolesRef = doc(db, "approved_emails", user.email);
        const userRolesSnap = await getDoc(userRolesRef);

        if (userRolesSnap.exists()) {
            const roles = userRolesSnap.data().role.toLowerCase();
            if (!roles.includes('plus') && !roles.includes('verified')) {
                upgradeBtn.style.display = 'inline-block';
            }
        }
    }

    if (!reviewingSetId || !collectionName) {
        document.querySelector('.blitz-main-container').innerHTML = "<h2 style='color:white; text-align:center;'>Error: No set ID found. Please go back and select a set.</h2>";
        return;
    }

    try {
        const setRef = doc(db, collectionName, reviewingSetId);
        const docSnap = await getDoc(setRef);

        if (docSnap.exists()) {
            const setData = docSnap.data();
            originalFlashcards = docSnap.data().flashcards || [];
            populatePageInfo(setData);

            if (originalFlashcards.length < 2) {
                document.querySelector('.blitz-main-container').innerHTML = `<h2 style='color:white; text-align:center;'>Blitz mode requires at least 2 cards in a set.</h2>`;
                return;
            }
            
            let hasSavedProgress = false;
            if (user && !user.isAnonymous) {
                const savedProgressRef = doc(db, "blitzsaved", user.email);
                const savedProgressSnap = await getDoc(savedProgressRef);

                if (savedProgressSnap.exists()) {
                    const allSavedGames = savedProgressSnap.data();
                    const savedProgress = allSavedGames[reviewingSetId];

                    if (savedProgress) {
                        hasSavedProgress = true;
                        const modalMessage = document.querySelector('#startScreen .modal-message');
                        const modalButtons = document.querySelector('#startScreen .modal-buttons');

                        modalMessage.innerHTML = `
                            <h2 style="margin-top: 0; font-size: 2rem;">Resume Session?</h2>
                            <p>You have a game in progress (${savedProgress.score}/${savedProgress.questions.length} correct). Continue where you left off?</p>
                        `;
                        
                        modalButtons.innerHTML = `
                            <button id="resumeBtn" class="neumorphic-button">Resume</button>
                            <button id="newGameBtn" class="neumorphic-button">Start New</button>
                        `;

                        document.getElementById('resumeBtn').addEventListener('click', () => resumeGame(savedProgress));
                        document.getElementById('newGameBtn').addEventListener('click', async () => {
                            try {
                                await updateDoc(savedProgressRef, { [reviewingSetId]: deleteField() });
                            } catch (error) {
                                console.warn("Could not remove old progress.", error.message);
                            }
                            startGame();
                        });
                    }
                }
            }

            startScreen.style.display = 'flex';
            if (!hasSavedProgress) {
                startGameBtn.disabled = false;
                startGameBtn.textContent = "Start Game";
            }

        } else {
             document.querySelector('.blitz-main-container').innerHTML = "<h2 style='color:white; text-align:center;'>Error: Could not find set.</h2>";
        }
    } catch (error) {
        console.error("Error loading set:", error);
         document.querySelector('.blitz-main-container').innerHTML = "<h2 style='color:white; text-align:center;'>Error loading set data.</h2>";
    }
});
    function generateQuestions() {
        questions = originalFlashcards.map((card, index) => {
            const isTrueQuestion = Math.random() > 0.5;
            if (isTrueQuestion) {
                return { term: card.term, definition: card.definition, correct: true };
            } else {
                let randomIndex;
                do {
                    randomIndex = Math.floor(Math.random() * originalFlashcards.length);
                } while (randomIndex === index);
                return { term: card.term, definition: originalFlashcards[randomIndex].definition, correct: false };
            }
        });
        questions.sort(() => Math.random() - 0.5);
    }

    // blitz.html
async function startGame() {
    // ▼▼▼ NEW LOGIC TO CREATE THE DOCUMENT ON START ▼▼▼
    const user = auth.currentUser;
    if (user && !user.isAnonymous) {
        try {
            const savedProgressRef = doc(db, "blitzsaved", user.email);
            // This safely creates the document with no fields if it doesn't exist.
            // If it already exists, merge:true ensures we don't overwrite it.
            await setDoc(savedProgressRef, {}, { merge: true });
            console.log("Ensured blitzsaved document exists for user.");
        } catch (error) {
            console.error("Error ensuring blitzsaved document exists:", error);
        }
    }
    // ▲▲▲ END OF NEW LOGIC ▲▲▲

    clearInterval(timerInterval);
    generateQuestions();

    currentIndex = 0;
    score = 0;
    startScreen.classList.add('hidden');
    resultsScreen.classList.add('hidden');
    gameContainer.classList.remove('hidden');

    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 1000);

    displayQuestion();
}

    // ▼▼▼ UPDATED DISPLAYQUESTION FUNCTION ▼▼▼
// --- NEW: Helper function to adjust font size ---
    function adjustFontSize(element, elementType = 'element') {
    if (!element || element.tagName === 'IMG') {
        console.log(`AdjustFontSize: Skipped for non-existent or IMG element (${elementType}).`);
        return;
    }

    console.log(`--- Adjusting Font Size for: ${elementType} ---`);
    element.style.fontSize = ''; // Reset to CSS default

    const computedStyle = window.getComputedStyle(element);
    const initialSizeRem = parseFloat(computedStyle.fontSize) / 16; // Convert px to rem
    console.log(`Initial default font size: ${initialSizeRem.toFixed(2)}rem`);
    console.log(`Overflow check: scrollHeight(${element.scrollHeight}) > clientHeight(${element.clientHeight}) OR scrollWidth(${element.scrollWidth}) > clientWidth(${element.clientWidth})`);

    if (element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth) {
        console.log("%cOverflow detected. Starting font size reduction loop.", "color: orange;");
        let currentSize = initialSizeRem;

        while ((element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth) && currentSize > 0.5) {
            currentSize -= 0.1;
            element.style.fontSize = `${currentSize}rem`;
            console.log(`  -> Trying size: ${currentSize.toFixed(1)}rem`);
        }
        console.log(`%cLoop finished. Final font size: ${currentSize.toFixed(1)}rem`, "color: lightgreen;");
    } else {
        console.log("No overflow detected. Font size remains at default.");
    }
    console.log(`-------------------------------------------`);
}

    // ▼▼▼ UPDATED DISPLAYQUESTION FUNCTION ▼▼▼
    function displayQuestion() {
    if (!questions[currentIndex]) {
        endGame(); 
        return; 
    }

    const q = questions[currentIndex];

    const termContent = isImageUrl(q.term)
        ? `<img src="${q.term}" alt="Term Image" class="blitz-image">`
        : `<p class="term">${q.term}</p>`;

    const defContent = isImageUrl(q.definition)
        ? `<img src="${q.definition}" alt="Definition Image" class="blitz-image">`
        : `<p class="def"><strong>${q.definition}</strong></p>`;

    blitzStatement.innerHTML = `
        <div class="blitz-question-part">
            <span class="blitz-label">Term:</span>
            ${termContent}
        </div>
        <div class="blitz-question-part">
            <span class="blitz-label">Definition:</span>
            ${defContent}
        </div>
    `;
    progressTracker.textContent = `${currentIndex + 1} / ${questions.length}`;

    // --- Adjust font sizes with logging ---
// Use setTimeout to allow the browser to render the content first
        // Adjust font sizes now that content is set
        const termElement = blitzStatement.querySelector('.term');
        const defElement = blitzStatement.querySelector('.def strong');

        adjustFontSize(termElement, 'Term');
        adjustFontSize(defElement, 'Definition');
}
    // ▲▲▲ END OF UPDATED FUNCTION ▲▲▲

    function checkAnswer(userChoice) {
    // ▼▼▼ ADD THIS CHECK ▼▼▼
    // If the game is already over, do nothing. This prevents
    // errors from rapid clicks on the last question.
    if (currentIndex >= questions.length) {
        return;
    }
    // ▲▲▲ END OF ADDED CHECK ▲▲▲

    trueBtn.disabled = true;
    falseBtn.disabled = true;

    const isCorrect = userChoice === questions[currentIndex].correct;
    const animationClass = isCorrect ? 'slide-correct' : 'slide-incorrect';
    const bodyFlashClass = isCorrect ? 'correct-flash' : 'incorrect-flash';

    if (isCorrect) {
        score++;
    }
    saveProgress();
    document.body.classList.add(bodyFlashClass);
    gameContainer.classList.add(animationClass);

    setTimeout(() => {
        document.body.classList.remove(bodyFlashClass);
    }, 300);

    setTimeout(() => {
        gameContainer.classList.remove(animationClass);
        currentIndex++;

        if (currentIndex >= questions.length) {
            endGame();
        } else {
            displayQuestion();
        }

        trueBtn.disabled = false;
        falseBtn.disabled = false;
    }, 600);
}

    // blitz.html -> <script>

// ▼▼▼ REPLACE THE endGame FUNCTION WITH THIS ASYNC VERSION ▼▼▼
async function endGame() {
    clearInterval(timerInterval);
    const user = auth.currentUser;
    const reviewingSetId = localStorage.getItem("reviewingSetId");

    // ▼▼▼ LOGIC TO APPEND SCORE AND INCREMENT TOTAL ▼▼▼
    if (user && !user.isAnonymous && reviewingSetId && currentIndex >= questions.length) {
        try {
            const userDocRef = doc(db, 'blitzcorrect', user.email);

            const newScoreEntry = {
                score: score,
                totalQuestions: questions.length,
                setId: reviewingSetId,
                timestamp: new Date()
            };

            // This now does two things:
            // 1. Adds the new game's record to the 'scores' array.
            // 2. Adds the current score to the 'totalScore' field.
            await setDoc(userDocRef, {
                scores: arrayUnion(newScoreEntry),
                totalScore: increment(score) // ▼▼▼ THIS IS THE NEW LINE ▼▼▼
            }, { merge: true });

            console.log("Score record added and total score updated.");

        } catch (error) {
            console.error("Failed to save score:", error);
        }
    }
    // ▲▲▲ END OF LOGIC ▲▲▲

    // Clear any saved in-progress game from Firestore
    if (user && !user.isAnonymous && reviewingSetId) {
        try {
            const savedProgressRef = doc(db, "blitzsaved", user.email);
            await updateDoc(savedProgressRef, {
                [reviewingSetId]: deleteField()
            });
            console.log("In-progress game data removed from Firestore.");
        } catch (error) {
            console.warn("Could not remove in-progress game data:", error.message);
        }
    }
    
    const totalTime = Date.now() - startTime;

    gameContainer.classList.add('hidden');
    resultsScreen.classList.remove('hidden');
    progressTracker.textContent = '';
    
    finalScore.textContent = `Score: ${score} / ${questions.length}`;
    timeTaken.textContent = `Time: ${formatTime(totalTime)}`;
} 
    function updateTimer() {
        const elapsedTime = Date.now() - startTime;
        timerDisplay.textContent = formatTime(elapsedTime);
    }

    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
        const seconds = (totalSeconds % 60).toString().padStart(2, '0');
        return `${minutes}:${seconds}`;
    }

    function populatePageInfo(setData) {
        document.getElementById("setTitle").textContent = setData.title || "Untitled Set";
        document.getElementById("descriptionBox").textContent = setData.description || "No description provided.";
        document.getElementById("cardCategory").textContent = setData.category || "General";
        
        const creatorEmail = setData.creatorEmail || setData.user;
        if (creatorEmail) {
            const usernameRef = doc(db, "usernames", creatorEmail);
            getDoc(usernameRef).then(usernameSnap => {
                if (usernameSnap.exists() && usernameSnap.data().username) {
                    document.getElementById("cardCreator").textContent = usernameSnap.data().username;
                } else {
                    document.getElementById("cardCreator").textContent = creatorEmail.split('@')[0];
                }
            });
        } else {
            document.getElementById("cardCreator").textContent = "N/A";
        }
    }
// blitz.html -> <script>

// ▼▼▼ ADD OR REPLACE THESE TWO FUNCTIONS ▼▼▼
async function saveProgress() {
    const user = auth.currentUser;
    const reviewingSetId = localStorage.getItem("reviewingSetId");

    // Can't save if not logged in or no set is active
    if (!user || user.isAnonymous || !reviewingSetId) {
        if (saveProgressCheckbox.checked) {
            console.warn("Save progress is on, but no user is logged in. Cannot save.");
            // Optionally uncheck the box and notify the user
            // saveProgressCheckbox.checked = false; 
            // alert("You must be logged in to save progress.");
        }
        return;
    }

    const savedProgressRef = doc(db, "blitzsaved", user.email);

    if (saveProgressCheckbox.checked && currentIndex < questions.length) {
        const progress = {
            questions: questions,
            currentIndex: currentIndex,
            score: score,
            elapsedTime: Date.now() - startTime,
            savedAt: new Date() // Good practice to add a timestamp
        };
        try {
            // Using setDoc with merge:true updates the field for the current set
            // without affecting progress saved for other sets.
            await setDoc(savedProgressRef, { [reviewingSetId]: progress }, { merge: true });
            console.log("Progress saved to Firestore.");
        } catch (error) {
            console.error("Error saving progress to Firestore:", error);
        }
    } else {
        // If toggle is off or unchecked, remove the progress for this specific set
        try {
            await updateDoc(savedProgressRef, {
                [reviewingSetId]: deleteField()
            });
            console.log("Progress removed from Firestore.");
        } catch (error) {
            // This might error if the document/field doesn't exist, which is fine.
            console.warn("Could not remove progress from Firestore:", error.message);
        }
    }
}

function resumeGame(savedProgress) {
    if (!savedProgress) {
        console.error("Resume function called without saved progress object.");
        startGame(); // Fallback to a new game
        return;
    }
    
    // Load state from the passed saved progress object
    questions = savedProgress.questions;
    currentIndex = savedProgress.currentIndex;
    score = savedProgress.score;
    // Recalculate start time to continue the timer correctly
    startTime = Date.now() - savedProgress.elapsedTime; 
    
    saveProgressCheckbox.checked = true;

    // Start the game UI
    clearInterval(timerInterval);
    startScreen.classList.add('hidden');
    resultsScreen.classList.add('hidden');
    gameContainer.classList.remove('hidden');
    
    timerInterval = setInterval(updateTimer, 1000);
    displayQuestion();
}
    // --- Event Listeners ---
    startGameBtn.addEventListener('click', startGame);
    playAgainBtn.addEventListener('click', startGame);
    retryBtn.addEventListener('click', startGame);
    trueBtn.addEventListener('click', () => checkAnswer(true));
    falseBtn.addEventListener('click', () => checkAnswer(false));
    saveProgressCheckbox.addEventListener('change', saveProgress);
      document.addEventListener('keydown', (event) => {
    // Only trigger shortcuts if the game is active
    if (!gameContainer.classList.contains('hidden')) {
      if (event.key === 'ArrowLeft') {
        event.preventDefault(); // Prevent browser from going back
        falseBtn.click();
      } else if (event.key === 'ArrowRight') {
        event.preventDefault();
        trueBtn.click();
      }
    }
  });
  const howToBtn = document.getElementById('howToBtn');
const howToModal = document.getElementById('howToModal');
const closeHowToModalBtn = document.getElementById('closeHowToModalBtn');

howToBtn.addEventListener('click', () => {
    howToModal.classList.remove('hidden');
});

closeHowToModalBtn.addEventListener('click', () => {
    howToModal.classList.add('hidden');
});
</script>
<script src="protect.js"></script>
<script type="module" src="presence.js"></script>
</body>
</html>