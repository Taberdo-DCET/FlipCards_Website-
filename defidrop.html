<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>DefiDrop | FlipCards</title>
  <link rel="icon" type="image/png" sizes="32x32" href="Group-100.png">
  <link rel="stylesheet" href="defidrop.css">
</head>
<body>
  <h1 id="setTitle">Study Mode</h1>



  <div class="button-container">
    <button class="neumorphic-button" onclick="navigateToMode('flashcard.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
</svg>Flashcard</button>
    <button class="neumorphic-button" onclick="navigateToMode('test.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="m10.4 12.6-2.8 2.8"></path><path d="m10.4 15.4-2.8-2.8"></path><path d="M12 18h6"></path>
</svg>Test</button>
    <button id="blitzButton" class="neumorphic-button" onclick="navigateToMode('blitz.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
</svg>
    Blitz
    <img src="new.png" alt="New Feature" class="new-icon">
</button>
    <button class="neumorphic-button" onclick="navigateToMode('learn.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.232 5.232a3 3 0 0 1 0 4.242L12 12.728l-3.232-3.232a3 3 0 0 1 0-4.242a3 3 0 0 1 4.242 0z"></path><path d="M12 12.728 8.768 9.496a3 3 0 0 1 0 4.242L12 17.228l3.232-3.232a3 3 0 0 1 0-4.242z"></path>
</svg>Learn</button>
    <button class="neumorphic-button" onclick="navigateToMode('match.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 7h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2z"></path><path d="M10 7V5.5a1.5 1.5 0 0 1 3 0V7"></path><path d="M14 17v1.5a1.5 1.5 0 0 1-3 0V17"></path><path d="M7 10H5.5a1.5 1.5 0 0 0 0 3H7"></path><path d="M17 14h1.5a1.5 1.5 0 0 0 0-3H17"></path>
</svg>Match</button>
    <button class="neumorphic-button active" onclick="navigateToMode('defidrop.html')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"></path><path d="m19 12-7-7"></path>
</svg>DefiDrop</button>
</div>
  <div style="margin-top: -20px; margin-bottom: 30px;">
  <button class="neumorphic-button" onclick="scrollToInput()">‚ñ∂ Start</button>
    
</div>
<div class="oo">
  <a href="lobby.html#Folderr">
    <img src="homeenc.png" alt="Home" class="home-icon hover-switch" data-default="homeenc.png" data-hover="homeec.png" />
  </a>
  <div class="tooltip-container">
  <a id="multiplayerBtn">
    <img src="multinc.png" alt="Multiplayer" class="home-icon hover-switch" data-default="multinc.png" data-hover="multic.png" />
  </a>
  <div class="multiplayer-tooltip">Join Multiplayer Mode!</div>
</div>

</div>



<div class="rectangle-container">
  <div class="column"></div>
  <div class="column"></div>
  <div class="column"></div>
</div>





<div class="input-section" id="inputArea">
  <div id="timerContainer" style="display: flex; align-items: center; gap: 8px;">
   
    <div id="timerBarContainer">
      <div id="timerBar"></div>
      </div>
      <div id="timer">‚è≥ 60s</div>

</div>
<button id="leaveMultiplayerBtn" class="neumorphic-button2" style="background:#ff4d4d; padding:6px 10px; font-size:12px; display:none;">
    Leave
  </button>
<div id="multiplayerTimer" style="display:none; background:#1e1e1e; padding:12px 16px; border-radius:8px; color:white; font-family:'QilkaBold'; box-shadow: 3px 3px 8px #0f0f0f, -3px -3px 8px #1f1f1f;">
   ‚è≥ 60s
</div>
  <input type="text" placeholder="Enter your input..." />
  <button onclick="submitInput()">Submit</button>
 <div id="counters">
  ‚úÖ <span id="correctCount">0</span> &nbsp;&nbsp;
  ‚ùå <span id="mistakeCount">0</span>
</div>

</div>
<div id="flipTimerModal" class="flip-timer-modal hidden">
  <div class="flip-timer-header">
    <span class="flip-timer-title">üïí FlipTimer</span>
    <span class="flip-timer-close" onclick="closeFlipTimer()">&times;</span>
  </div>
  <div class="flip-timer-body">
    <label for="studyMinutes">Study Minutes:</label>
    <input type="number" id="studyMinutes" min="1" max="180" placeholder="Enter minutes...">
    <h2 id="flipTimerLabel">Ready to Focus?</h2>
    <h1 id="flipTimerClock">00:00</h1>

    <div class="flip-timer-buttons">
      <button onclick="startFlipTimer()">Start</button>
      <button onclick="resetFlipTimer()">Reset</button>
      <button onclick="skipBreak()">Skip</button>
      <button onclick="pauseFlipTimer()" id="pauseButton">‚è∏Ô∏è Pause</button>
    </div>

    <p>Breaks Taken: <span id="breakCounter">0</span></p>
    <div style="text-align: center; margin-top: 10px;">
      <button id="collapseBtn" onclick="collapseFlipTimer()" class="neumorphic-button" style="padding: 4px 12px; font-size: 12px;">‚ñ≤ Collapse</button>
    </div>
  </div>
</div>

<!-- FlipTimer Minimized View -->
<div id="flipTimerMinimized" class="hidden" style="
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 10px 16px;
  border-radius: 16px;
  font-family: 'QilkaBold';
  font-size: 16px;
  z-index: 3000;
  gap: 10px;
  align-items: center;
  box-shadow: 6px 6px 12px rgba(0,0,0,0.3), -6px -6px 12px rgba(255,255,255,0.05);
  cursor: pointer;
  border: 1px solid white;
  backdrop-filter: blur(8px);
  display: flex;
">
<span id="minBreakCounter">0</span>
  <span id="flipTimerMinClock">00:00</span>
   <button onclick="expandFlipTimer()" class="neumorphic-button" style="font-size: 12px; padding: 4px 10px;">‚ñ≤ Expand</button>
</div>

<!-- Confirm Dialog -->
<div id="flipTimerConfirm" class="flip-timer-confirm hidden">
  <div class="flip-timer-confirm-box">
    <p>Want to continue?</p>
    <div>
      <button onclick="confirmFlipTimerContinue(true)">Yes</button>
      <button onclick="confirmFlipTimerContinue(false)">No</button>
    </div>
  </div>
</div>
<div id="summaryModal" class="modal-backdrop">
  <div class="modal-box">
    <h2>üß† Round Summary</h2>
    <p id="summaryText"></p>
    <button onclick="closeSummaryModal()">Claim XP!</button>
  </div>
</div>
<div id="multiplayerModal" class="modal-backdrop">
  <div class="modal-box" style="max-width: 700px; background:#171717; border-radius:20px; padding:0; max-height: 600px; display:flex; flex-direction:column;">
    
    <!-- Fixed Header -->
    <div class="modal-header" style="position: sticky; top:0; background:#171717; z-index:10; padding:10px; border-bottom:1px solid #333;">
      <h2 style="margin-bottom: 10px;">‚öîÔ∏è Multiplayer Lobby</h2>
      <div id="playerSlots" class="player-slots" style="margin-bottom: 10px;"></div>
    </div>

    <!-- Scrollable Body -->
    <div class="modal-body" style="flex:1; display:flex; flex-direction:column; padding:10px; gap:10px;">
      
      <div style="flex:1; display:flex; flex-direction:column; overflow:hidden;">
    <h3 style="margin-bottom: 6px; font-size: 1.1rem;">Recently Invited</h3>
    <div id="recentInvitesList" style="flex:1; overflow-y:auto; text-align:left;"></div>
  </div>
  <div style="flex:1; display:flex; flex-direction:column; overflow:hidden;">
    <h3 style="margin-bottom: 6px; font-size: 1.1rem;">Invite Players</h3>
    <input type="text" id="userSearch" placeholder="Search by username or email..." 
         style="width:80%; padding:8px; border-radius:8px; margin-bottom:8px; margin-left:28px; border:none; font-family:'QilkaBold';"/>
    <div id="userList" style="flex:1; overflow-y:auto; text-align:left;"></div>
  </div>

  
</div>


    <!-- Fixed Footer -->
    <div class="modal-footer" style="position: sticky; bottom:0; background:#171717; padding:10px; border-top:10px solid #333; padding-bottom: 5px; text-align:center;">
      <button onclick="closeMultiplayerModal()" style="padding:8px 16px;">Close</button>
    </div>
  </div>
</div>
<div id="rankingModal" class="modal-backdrop" style="display:none;">
  <div class="modal-box" style="max-width:700px; text-align:left; background:#171717;">
    <h2 style="text-align:center; margin-bottom:20px;">üèÜ Round Results</h2>
    <div id="rankingList"></div>
    <div style="margin-top:20px; text-align:center;">
      <button id="oneMoreRoundBtn" class="neumorphic-button2" style="margin-right:10px;">One More Round</button>
      <button id="leaveBtn" class="neumorphic-button2" style="background:#ff4d4d;">Leave</button>
    </div>
  </div>
</div>
<div id="leaveNotification" style="
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 20px;
  border-radius: 12px;
  display: none;
  font-family: 'QilkaBold';
  font-size: 14px;
  color: white;
  background: rgba(23, 23, 23, 0.6);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  border: 1px solid rgba(255,255,255,0.1);
  z-index: 9999;
  animation: slideIn 0.4s ease forwards;
">
</div>





<script src="flipTimer.js"></script>


<script type="module" src="xpTracker.js"></script>
<script>
  const reviewingSet = JSON.parse(localStorage.getItem("reviewingSet"));
  const currentIndex = parseInt(localStorage.getItem("currentIndex") || "0");

  

  let flashcards = reviewingSet ? reviewingSet.flashcards : [];
  document.getElementById("setTitle").textContent = reviewingSet.title || "Study Mode";

  const columns = document.querySelectorAll(".column");
  let correct = 0;
  let mistakes = 0;
  let sessionActive = false;
  const maxCardsPerColumn = 4;

  function updateCounters() {
  const correctEl = document.getElementById("correctCount");
  const mistakeEl = document.getElementById("mistakeCount");

  if (correctEl) correctEl.textContent = correct;
  if (mistakeEl) mistakeEl.textContent = mistakes;
}


  function getRandomFlashcard() {
    return flashcards[Math.floor(Math.random() * flashcards.length)];
  }

  function createDefinitionBlock(card, column) {
    const block = document.createElement("div");
    block.className = "definition-block";
    if (typeof card.definition === "string" && card.definition.includes("firebasestorage.googleapis.com")) {
  const img = document.createElement("img");
  img.src = card.definition;
  img.alt = "Definition Image";
  img.style.maxWidth = "100%";
  img.style.maxHeight = "100px";
  img.style.borderRadius = "8px";
  block.appendChild(img);
} else {
  block.textContent = card.definition;
}

    block.dataset.term = card.term;
    block.style.animation = "dropIn 0.5s ease-out";

    block.onclick = () => {
      if (!sessionActive) return;
      document.querySelectorAll('.definition-block').forEach(b => b.classList.remove('selected'));
      block.classList.add('selected');
      document.querySelector('.input-section input').focus();
    };

    column.appendChild(block);
  }

  function populateAllColumns() {
  columns.forEach(col => col.innerHTML = "");

  const usedDefinitions = new Set();
  let availableCards = [...flashcards];
  let bonusInserted = false;
  let totalSlots = columns.length * maxCardsPerColumn;
  let slotIndex = 0;

  while (slotIndex < totalSlots) {
    let cardToInsert = null;

    // Insert the bonus card if needed
    if (flashcards.length < 16 && !bonusInserted && (Math.random() < 0.3 || availableCards.length === 0)) {
      cardToInsert = {
        definition: "üéÅ Type Bonus For Answer",
        term: "bonus"
      };
      bonusInserted = true;
    } else {
      // Pick unique flashcard
      while (availableCards.length > 0) {
        const idx = Math.floor(Math.random() * availableCards.length);
        const candidate = availableCards[idx];
        const defKey = typeof candidate.definition === 'string' ? candidate.definition : JSON.stringify(candidate.definition);
        if (!usedDefinitions.has(defKey)) {
          cardToInsert = candidate;
          usedDefinitions.add(defKey);
          availableCards.splice(idx, 1); // Remove to avoid reuse
          break;
        } else {
          availableCards.splice(idx, 1);
        }
      }

      // If no more unique cards, allow bonus card as fallback
      if (!cardToInsert && flashcards.length < 16 && !bonusInserted) {
        cardToInsert = {
          definition: "üéÅ Type Bonus For Answer",
          term: "bonus"
        };
        bonusInserted = true;
      }
    }

    if (cardToInsert) {
      const colIndex = slotIndex % columns.length;
      createDefinitionBlock(cardToInsert, columns[colIndex]);
      slotIndex++;
    } else {
      break; // Stop if nothing more to show
    }
  }
}


  function submitInput() {
    if (!sessionActive) return;

    const input = document.querySelector('.input-section input');
    const answer = input.value.trim().toLowerCase();
    const selected = document.querySelector('.definition-block.selected');

    if (!selected) {
      input.value = '';
      return;
    }

    const correctAnswer = selected.dataset.term?.toLowerCase();
    const column = selected.parentElement;

    if (answer === correctAnswer) {
      correct++;
      selected.style.animation = 'shrinkOut 0.4s forwards';
      setTimeout(() => {
        selected.remove();
        const card = getRandomFlashcard();
        createDefinitionBlock(card, column);
      }, 400);
    } else {
      mistakes++;
      selected.classList.add('wrong');
      setTimeout(() => selected.classList.remove('wrong'), 600);
    }

    updateCounters();
    input.value = '';
    selected.classList.remove('selected');
  }

  let timeLeft = 60;
  let timerStarted = false;
  let timerInterval;
  const timerDisplay = document.getElementById("timer");

  function startTimer() {
  if (timerStarted) return;
  timerStarted = true;

  const timerBar = document.getElementById("timerBar");

  timerInterval = setInterval(() => {
    timeLeft--;
    timerDisplay.textContent = `‚è≥ ${timeLeft}s`;

    const percentage = (timeLeft / 60) * 100;
    timerBar.style.width = `${Math.max(0, percentage)}%`;

if (timeLeft <= 10) {
  timerBar.classList.add("pulse");
} else {
  timerBar.classList.remove("pulse");
}


    if (timeLeft <= 0) {
      clearInterval(timerInterval);
      timerDisplay.textContent = "‚è≥ Time's up!";
      timerBar.style.width = `0%`;
      timerBar.classList.remove("pulse");


      const xpGained = correct * 100;
      setTimeout(() => {
        showResultsPopup(correct, mistakes, xpGained);
      }, 400);
    }
  }, 1000);
}


  function scrollToInput() {
    const inputArea = document.getElementById("inputArea");
    inputArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
    document.activeElement.blur();
    populateAllColumns();
    sessionActive = true;
    correct = 0;
    mistakes = 0;
    updateCounters();
    timeLeft = 60;
    timerStarted = false;
    startTimer();
  }

  function showResultsPopup(correctVal, mistakeVal, xp) {
  const modal = document.getElementById("summaryModal");
  const text = document.getElementById("summaryText");

  text.innerText =
    `‚úÖ Correct: ${correctVal}\n‚ùå Mistakes: ${mistakeVal}\n‚≠ê Total XP Earned: ${xp}`;

  modal.style.display = "flex";

  // Defer XP reward to after user closes modal
  modal.dataset.xp = xp;
}





  document.querySelector('.input-section input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const selected = document.querySelector('.definition-block.selected');
      if (selected) {
        submitInput();
      }
    }
  });
// --- ADD THIS ENTIRE FUNCTION ---
  function navigateToMode(modeUrl) {
    // This function will handle navigating to other game modes.
    window.location.href = modeUrl;
  }
function goToFlashcard() { navigateToMode("flashcard.html"); }
  function goToMatch() { navigateToMode("match.html"); }
  function goToLearn() { navigateToMode("learn.html"); }
  function goToTest() { navigateToMode("test.html"); }
  function goToDefidrop() { navigateToMode("defidrop.html"); }
</script>
<script>
  // Existing logic here...

  // Hover-switch for home icon
  document.querySelectorAll(".hover-switch").forEach(img => {
    const def = img.getAttribute("data-default");
    const hov = img.getAttribute("data-hover");
    img.addEventListener("mouseover", () => img.src = hov);
    img.addEventListener("mouseout", () => img.src = def);
  });
</script>
<script type="module" src="xpTracker.js"></script>
<script type="module">
  import { checkUserStatus } from './userstatuscheck.js';
  checkUserStatus();
</script>
<script type="module" src="presence.js"></script>
<script type="module">
  import { auth, db } from './firebaseinit.js';
  import { doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

  window.closeSummaryModal = async function () {
  const modal = document.getElementById("summaryModal");
  const xp = parseInt(modal.dataset.xp || "0");

  // Add visual feedback: disable button & show loading text
  const claimBtn = modal.querySelector("button");
  claimBtn.disabled = true;
  claimBtn.innerText = "Saving...";

  if (typeof addXP === "function" && xp > 0) {
    addXP(xp);
  }

  try {
    const user = auth.currentUser;
    if (user) {
      const userEmail = user.email;
      const defidropRef = doc(db, "defidrop_scores", userEmail);
      const snap = await getDoc(defidropRef);

      let previous = 0;
      if (snap.exists() && snap.data().totalCorrect) {
        previous = parseInt(snap.data().totalCorrect);
      }

      await setDoc(defidropRef, { totalCorrect: previous + correct }, { merge: true });

      // Optional success animation or message
      claimBtn.innerText = "‚úÖ Saved!";
      setTimeout(() => {
        modal.style.display = "none";
        resetGame();
      }, 800); // delay to let user see feedback
    } else {
      console.warn("‚ö†Ô∏è User not signed in.");
      claimBtn.innerText = "‚ùå Not Signed In";
    }
  } catch (err) {
    console.error("‚ùå Save failed:", err);
    claimBtn.innerText = "‚ùå Error";
  } finally {
    setTimeout(() => {
      claimBtn.disabled = false;
      claimBtn.innerText = "Claim XP!";
    }, 2000);
  }
};

function resetGame() {
  correct = 0;
  mistakes = 0;
  sessionActive = false;
  updateCounters();
}

</script>

<script type="module" src="multiplayer.js"></script>
<script type="module" src="multiplayer.js"></script>

<script type="module">
import { auth, db } from './firebaseinit.js';
import { doc, getDoc, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

// Multiplayer Timer Variables
let multiplayerTimeLeft = 60;
let multiplayerTimerInterval = null;
let multiplayerTimerDisplay = null;

function showCountdown(seconds, callback) {
  const overlay = document.createElement("div");
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,1);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2em;
    z-index: 9999;
    font-family: 'QilkaBold';
  `;
  document.body.appendChild(overlay);

  overlay.innerText = `Game starting in ${seconds}...`;
  let countdown = seconds;
  const interval = setInterval(() => {
    countdown--;
    if (countdown > 0) {
      overlay.innerText = `Game starting in ${countdown}...`;
    } else {
      clearInterval(interval);
      document.body.removeChild(overlay);
      if (callback) callback();
    }
  }, 1000);
}

// Multiplayer Timer Logic
async function startMultiplayerTimer() {
  if (!multiplayerTimerDisplay) {
    multiplayerTimerDisplay = document.getElementById("multiplayerTimer");
  }

  const params = new URLSearchParams(window.location.search);
  const host = params.get("host");
  if (!host) return;


  const gameDocRef = doc(db, "gamestartlobby", host);
  const snapshot = await getDoc(gameDocRef);
  if (!snapshot.exists()) return;

  const data = snapshot.data();
  const endTime = data.endTime;
  if (!endTime) return;

  function updateTimer() {
    const remaining = Math.max(0, endTime - Date.now());
    const seconds = Math.floor(remaining / 1000);
    multiplayerTimerDisplay.textContent = `‚è≥ ${seconds}s`;

    if (remaining <= 0) {
      clearInterval(multiplayerTimerInterval);
      multiplayerTimerDisplay.textContent = "‚è≥ Time's up!";
      showRankingModal();
    }
  }

  clearInterval(multiplayerTimerInterval);
  multiplayerTimerDisplay.style.display = "flex";
  updateTimer(); // Initial call
  multiplayerTimerInterval = setInterval(updateTimer, 1000);
}




// Multiplayer score rendering
function renderMultiplayerScores(players, host) {
  const container = document.getElementById("counters");
  if (!container) return;

  // Replace contents of #counters with multiplayer scores
  container.innerHTML = players.map((p, index) => {
    const playerLabel = `P${index + 1}${p.email === host ? " (host)" : ""}`;
    const correct = Number(p.correctScore) || 0;
    const incorrect = Number(p.incorrectScore) || 0;
    return `
      <div style="display:flex; flex-direction:column; align-items:center; margin: 0 10px;">
        <span>${playerLabel}</span>
        <div style="white-space: nowrap; display: inline-flex; gap: 2px; align-items: center;">
  <span style="color:lime; font-weight:bold;">${correct}</span> /
  <span style="color:red; font-weight:bold;">${incorrect}</span>
</div>

      </div>`;
  }).join("");
}





// Listen to updates from gamestartlobby
function listenToGameScores(host) {
  const gameDocRef = doc(db, "gamestartlobby", host);
  onSnapshot(gameDocRef, (snapshot) => {
    if (snapshot.exists()) {
      const data = snapshot.data();
      if (data.players) {
        renderMultiplayerScores(data.players, host);
        if (data.lastLeaveNotification) {
  showLeaveNotification(data.lastLeaveNotification);
}

      }
    }
  });
}
function listenForGameRestart(host) {
  const gameDocRef = doc(db, "gamestartlobby", host);
  let lastEndTime = null;

  onSnapshot(gameDocRef, (snapshot) => {
    if (snapshot.exists()) {
      const data = snapshot.data();
      if (data.endTime && data.endTime !== lastEndTime) {
        lastEndTime = data.endTime;

        // Hide ranking modal for all players
        const rankingModal = document.getElementById("rankingModal");
        if (rankingModal) rankingModal.style.display = "none";

        console.log("Game restart detected, starting countdown...");
        showCountdown(5, startMultiplayerGame);
      }
    }
  });
}


// Show ranking modal
async function showRankingModal() {
  const params = new URLSearchParams(window.location.search);
  const host = params.get("host");
  if (!host) return;

  const modal = document.getElementById("rankingModal"); // <--- ADD THIS
  const gameDocRef = doc(db, "gamestartlobby", host);

  // Reset all players' ready to false
  let players = [];
  const currentSnap = await getDoc(gameDocRef);
  if (currentSnap.exists()) {
    players = (currentSnap.data().players || []).map(p => ({ ...p, ready: false }));
    await setDoc(gameDocRef, { players }, { merge: true });
  }

  // Real-time listener
  onSnapshot(gameDocRef, (snapshot) => {
    if (snapshot.exists()) {
      const data = snapshot.data();
      if (data.players) {
        updateRankingUI(data.players, host);
        updateStartButton(data.players, host);
      }
    }
  });

  modal.style.display = "flex";

  const oneMoreBtn = modal.querySelector("#oneMoreRoundBtn");
  const leaveBtn = modal.querySelector("#leaveBtn");

  // "One More Round" toggle
  oneMoreBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user) return;

    const latestSnap = await getDoc(gameDocRef);
    if (!latestSnap.exists()) return;

    const currentPlayers = (latestSnap.data().players || []).map(pl => {
      if (pl.email === user.email) return { ...pl, ready: !pl.ready };
      return pl;
    });

    await setDoc(gameDocRef, { players: currentPlayers }, { merge: true });
  };



  // Leave button
  leaveBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user) return;

    try {
      // Remove from gamestartlobby
      const updatedPlayers = players.filter(pl => pl.email !== user.email);
      await setDoc(gameDocRef, { players: updatedPlayers }, { merge: true });

      // Remove from lobbies
      const lobbyDocRef = doc(db, "lobbies", host);
      const lobbySnap = await getDoc(lobbyDocRef);
      if (lobbySnap.exists()) {
        const lobbyData = lobbySnap.data();
        const newLobbyPlayers = (lobbyData.players || []).filter(p => p.email !== user.email);
        await setDoc(lobbyDocRef, { players: newLobbyPlayers }, { merge: true });
      }

      // If host leaves, delete documents
      if (user.email === host) {
        const { deleteDoc } = await import("https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js");
        await deleteDoc(gameDocRef);
        await deleteDoc(lobbyDocRef);
      }

      window.location.href = "lobby.html";
    } catch (err) {
      console.error("Error while leaving:", err);
    }
  };
}
document.getElementById("leaveMultiplayerBtn")?.addEventListener("click", async () => {
  const params = new URLSearchParams(window.location.search);
  const host = params.get("host");
  if (!host) return;

  const user = auth.currentUser;
  if (!user) return;

  try {
    const gameDocRef = doc(db, "gamestartlobby", host);
    const currentSnap = await getDoc(gameDocRef);
    let players = [];
    if (currentSnap.exists()) {
      players = currentSnap.data().players || [];
    }
    const updatedPlayers = players.filter(pl => pl.email !== user.email);
    await setDoc(gameDocRef, { players: updatedPlayers }, { merge: true });

    // Remove from lobbies
    const lobbyDocRef = doc(db, "lobbies", host);
    const lobbySnap = await getDoc(lobbyDocRef);
    if (lobbySnap.exists()) {
      const lobbyData = lobbySnap.data();
      const newLobbyPlayers = (lobbyData.players || []).filter(p => p.email !== user.email);
      await setDoc(lobbyDocRef, { players: newLobbyPlayers }, { merge: true });
    }

    if (user.email === host) {
      const { deleteDoc } = await import("https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js");
      await deleteDoc(gameDocRef);
      await deleteDoc(lobbyDocRef);
    }
await setDoc(gameDocRef, { lastLeaveNotification: `${user.email} left the game` }, { merge: true });

    window.location.href = "lobby.html";
  } catch (err) {
    console.error("Error while leaving:", err);
  }
});

async function getUsernameByEmail(email) {
  const userDocRef = doc(db, "usernames", email);
  const userDoc = await getDoc(userDocRef);
  return userDoc.exists() ? userDoc.data().username : email;
}
async function getUserBadge(email) {
  try {
    const approvedDoc = await getDoc(doc(db, "approved_emails", email));
    if (approvedDoc.exists()) {
      const data = approvedDoc.data();
      const roleString = data.role || "";
      const roleArray = roleString.split(',').map(r => r.trim().toLowerCase());

      let badges = "";
      if (roleArray.includes("verified")) {
        badges += `<img src="verified.svg" alt="verified" title="Verified" class="badge-icon">`;
      }
      if (roleArray.includes("first")) {
        badges += `<img src="first.png" alt="first" title="First User" class="badge-icon">`;
      }
      return badges;
    }
  } catch (error) {
    console.error("Error fetching badge:", error);
  }
  return "";
}
async function updateRankingUI(players, host) {
  const rankingList = document.getElementById("rankingList");
  if (!rankingList) return;

  const playersWithDetails = await Promise.all(
    players.map(async (p) => {
      const username = await getUsernameByEmail(p.email);
      const badgesHTML = await getUserBadge(p.email);
      return { ...p, username, badgesHTML };
    })
  );

  // Sort players by correctScore (descending)
  playersWithDetails.sort((a, b) => (b.correctScore || 0) - (a.correctScore || 0));

  let winnerHTML = "";
  let othersHTML = "";

  playersWithDetails.forEach((p, index) => {
    const playerHTML = `
      <div class="player-row" data-email="${p.email}"
        style="display:flex; justify-content:space-between; align-items:center; background:#333; margin:5px 0; padding:8px; border-radius:6px; border:2px solid ${p.ready ? 'green' : '#ffcf00'};">
        <div style="display:flex; flex-direction:column; align-items:flex-start; gap:5px;">
          ${index === 0 ? '<span style="color:#ffcf00; font-weight:bold; font-size:14px; margin-left: 80px;">üèÜ Winner!</span>' : ''}
          <div style="display:flex; align-items:center; gap:10px;">
            <img src="${p.avatar}" style="width:40px; height:40px; border-radius:50%; border:2px solid ${p.ready ? 'green' : '#ffcf00'};" />
            <div>
              <div>${p.username} ${p.badgesHTML}</div>
              <div style="font-size:12px; opacity:0.7;">${p.email}</div>
            </div>
          </div>
        </div>
        <div style="font-size:18px; font-weight:bold;">${p.correctScore || 0}</div>
      </div>
    `;

    if (index === 0) {
      winnerHTML += playerHTML;
    } else {
      othersHTML += playerHTML;
    }
  });

  rankingList.innerHTML = winnerHTML + othersHTML;
}



function updateStartButton(players, host) {
  const oneMoreBtn = document.getElementById("oneMoreRoundBtn");
  if (!oneMoreBtn) return;

  const user = auth.currentUser;
  const allReady = players.every(p => p.ready);

  if (user && user.email === host && allReady) {
    oneMoreBtn.textContent = "Start Game";
    oneMoreBtn.onclick = async () => {
      await resetMultiplayerGame(host, doc(db, "gamestartlobby", host), players);
    };
  } else {
    oneMoreBtn.textContent = "One More Round";
  }
}

// Reset scores and start new round
async function resetMultiplayerGame(host, gameDocRef, players) {
  const resetPlayers = players.map(p => ({
    ...p,
    correctScore: 0,
    incorrectScore: 0,
    ready: false
  }));

  await setDoc(gameDocRef, {
    players: resetPlayers,
    endTime: Date.now() + 60000 // 60 sec timer
  }, { merge: true });

  // Hide ranking modal before starting countdown
  const rankingModal = document.getElementById("rankingModal");
  if (rankingModal) {
    rankingModal.style.display = "none";
  }

  showCountdown(5, startMultiplayerGame);
}



// Update score in Firestore
async function updatePlayerScore(isCorrect) {
  const params = new URLSearchParams(window.location.search);
  const host = params.get("host");
  if (!host) return;

  const user = auth.currentUser;
  if (!user) return;

  // 1. Update multiplayer scores
  const gameDocRef = doc(db, "gamestartlobby", host);
  const snapshot = await getDoc(gameDocRef);
  if (snapshot.exists()) {
    const data = snapshot.data();
    const players = data.players.map(p => {
      if (p.email === user.email) {
        return {
          ...p,
          correctScore: isCorrect ? p.correctScore + 1 : p.correctScore,
          incorrectScore: !isCorrect ? p.incorrectScore + 1 : p.incorrectScore
        };
      }
      return p;
    });
    await setDoc(gameDocRef, { players }, { merge: true });
  }

  // 2. Save correct answers to defidrop_scores
  if (isCorrect) {
    const scoreRef = doc(db, "defidrop_scores", user.email);
    const scoreSnap = await getDoc(scoreRef);
    let previous = 0;
    if (scoreSnap.exists() && scoreSnap.data().totalCorrect) {
      previous = parseInt(scoreSnap.data().totalCorrect);
    }
    await setDoc(scoreRef, { totalCorrect: previous + 1 }, { merge: true });
  }
}


async function loadGameSet() {
  multiplayerTimerDisplay = document.getElementById("multiplayerTimer");
  if (multiplayerTimerDisplay) multiplayerTimerDisplay.style.display = "none";

  let reviewingSet = JSON.parse(localStorage.getItem("reviewingSet"));
  const params = new URLSearchParams(window.location.search);
  let host = params.get("host");

  if (host) {
    document.getElementById("timerContainer").style.display = "none"; // hide solo timer
    if (multiplayerTimerDisplay) multiplayerTimerDisplay.style.display = "flex";
      const leaveBtn = document.getElementById("leaveMultiplayerBtn");
  if (leaveBtn) leaveBtn.style.display = "inline-block"; // Show the leave button

      const countersDiv = document.getElementById("counters");
if (countersDiv) {
  countersDiv.innerHTML = "";          // Clear solo counter
  countersDiv.style.display = "flex";  // Ensure it's visible
  countersDiv.style.gap = "15px";      // Add spacing for multiplayer score blocks
}




    const gameDoc = await getDoc(doc(db, "gamestartlobby", host));
    if (gameDoc.exists()) {
    const firebaseCardSet = gameDoc.data().cardSet;
    if (firebaseCardSet) {
        localStorage.setItem("reviewingSet", JSON.stringify(firebaseCardSet));
        reviewingSet = firebaseCardSet;
        document.getElementById("setTitle").textContent = reviewingSet.title;
flashcards = reviewingSet.flashcards;  // refresh the flashcards array
startMultiplayerGame();                // this will populate columns once with updated cards
  listenToGameScores(host); // <--- Added               // re-render the columns
  listenForGameRestart(host);


    } else {
        console.error("No cardSet in Firestore document.");
    }
}
  }

  if (host) {
    showCountdown(5, () => {
  if (reviewingSet && reviewingSet.title) {
    document.getElementById("setTitle").textContent = reviewingSet.title;
    startMultiplayerGame();  // <-- This already calls startMultiplayerTimer()
  }
});

  } else if (reviewingSet && reviewingSet.title) {
    document.getElementById("setTitle").textContent = reviewingSet.title;
  }
}

function startMultiplayerGame() {
  populateAllColumns();
  sessionActive = true;
  correct = 0;
  mistakes = 0;
  updateCounters();
  startMultiplayerTimer();  // keep only one call here

  // Scroll to input after 5 seconds (like solo mode)
  setTimeout(() => {
    const inputArea = document.getElementById("inputArea");
    if (inputArea) {
      inputArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }, 5000);
}




auth.onAuthStateChanged(user => {
  if (user) {
    loadGameSet();
    const interval = setInterval(() => {
      if (typeof window.submitInput === "function") {
        clearInterval(interval);
        const originalSubmit = window.submitInput;
        window.submitInput = function() {
          const inputField = document.querySelector('.input-section input');
          const answer = inputField?.value.trim().toLowerCase() || "";
          const selected = document.querySelector('.definition-block.selected');
          if (selected) {
            const correctAnswer = selected.dataset.term?.toLowerCase();
            const isCorrect = answer === correctAnswer;
            updatePlayerScore(isCorrect);
          }
          return originalSubmit.apply(this, arguments);
        };
      }
    }, 100);
  }
});
function showLeaveNotification(message) {
  const notif = document.getElementById("leaveNotification");
  if (!notif) return;
  
  notif.innerText = message;
  notif.style.display = "block";
  notif.style.animation = "none";
  notif.offsetHeight; // trigger reflow
  notif.style.animation = "slideIn 0.4s ease forwards";
  
  setTimeout(() => {
    notif.style.display = "none";
  }, 3000);
}


function attachMultiplayerInputHandler() {
  const inputField = document.querySelector('.input-section input');
  const submitBtn = document.querySelector('.input-section button');
  if (!inputField) return;
  inputField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') setTimeout(() => { inputField.value = ""; }, 10);
  });
  if (submitBtn) {
    submitBtn.addEventListener('click', () => {
      setTimeout(() => { inputField.value = ""; }, 10);
    });
  }
}
document.addEventListener('DOMContentLoaded', attachMultiplayerInputHandler);
</script>
<script src="protect.js"></script>
















</body>
</html>
